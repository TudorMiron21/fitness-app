"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpServerProxy = void 0;
const core_auth_1 = require("@azure/core-auth");
const utils_1 = require("./utils");
const http_1 = __importDefault(require("http"));
const TunnelConnection_1 = require("./tunnels/TunnelConnection");
const logger_1 = require("./logger");
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
const web_pubsub_1 = require("@azure/web-pubsub");
const apiVersion = "2023-07-01";
class HttpServerProxy {
    endpoint;
    credential;
    hub;
    _options;
    _tunnel;
    _client;
    id;
    static fromConnectionString(connectionString, hub, options, reverseProxyEndpoint) {
        const { credential, endpoint } = (0, utils_1.parseConnectionString)(connectionString);
        return new HttpServerProxy(endpoint, credential, hub, options, reverseProxyEndpoint);
    }
    constructor(endpoint, credential, hub, _options, reverseProxyEndpoint) {
        this.endpoint = endpoint;
        this.credential = credential;
        this.hub = hub;
        this._options = _options;
        this.endpoint = this.endpoint.endsWith("/") ? this.endpoint : this.endpoint + "/";
        this._tunnel = new TunnelConnection_1.TunnelConnection(endpoint, credential, hub, undefined, reverseProxyEndpoint);
        this._client = new web_pubsub_1.WebPubSubServiceClient(endpoint, credential, hub);
        this.id = this._tunnel.id;
    }
    runAsync(options, shouldRetry, abortSignal) {
        this._tunnel.requestHandler = (r, a) => this.sendHttpRequest(r, options, a);
        return this._tunnel.runAsync(shouldRetry, abortSignal);
    }
    // still doing the real REST API call to get the token
    async getClientAccessUrl(userId, roles, groups) {
        const cat = await this._client.getClientAccessToken({ userId, roles, groups });
        return cat.url;
    }
    getLiveTraceUrl() {
        return `${this.endpoint}livetrace`;
    }
    async getLiveTraceToken() {
        let token;
        if ((0, core_auth_1.isTokenCredential)(this.credential)) {
            return (await this.credential.getToken("https://webpubsub.azure.com")).token;
        }
        else {
            return jsonwebtoken_1.default.sign({}, this.credential.key, {
                audience: `${this.endpoint}livetrace`,
                expiresIn: "1h",
                algorithm: "HS256",
            });
        }
    }
    async sendHttpRequest(request, options, abortSignal) {
        function convertHeaders(headers) {
            const result = {};
            for (const key in headers) {
                const value = headers[key];
                if (value !== undefined) {
                    if (Array.isArray(value)) {
                        result[key] = value;
                    }
                    else {
                        result[key] = [value];
                    }
                }
            }
            return result;
        }
        function getDisplayUrl(url) {
            return `${request.HttpMethod} ${url} ${request.Content?.byteLength ?? 0}`;
        }
        function httpInvoke(url, request, abortSignal) {
            // always resolve, never reject
            function errorResponse(message) {
                return {
                    StatusCode: 500,
                    Headers: {},
                    Content: new TextEncoder().encode(message),
                };
            }
            return new Promise((resolve, reject) => {
                const req = http_1.default.request(url, {
                    method: request.HttpMethod,
                    headers: request.Headers,
                }, (res) => {
                    const chunks = [];
                    res.on("data", (chunk) => {
                        chunks.push(chunk);
                    });
                    res.on("end", () => {
                        logger_1.logger.info(`Received proxied response for '${getDisplayUrl(url)}: ${res.statusCode ?? 0}'`);
                        const tunnelResponse = {
                            StatusCode: res.statusCode ?? 0,
                            Headers: convertHeaders(res.headers),
                            Content: new Uint8Array(Buffer.concat(chunks)),
                        };
                        resolve(tunnelResponse);
                    });
                });
                req.on("error", (err) => {
                    logger_1.logger.error(`Error forwarding request '${getDisplayUrl(url)}': ${err}`);
                    resolve(errorResponse(err.message));
                });
                abortSignal?.addEventListener("abort", () => resolve(errorResponse("Request cancelled")));
                if (request.Content) {
                    // Java getBody() relies on Content-Length header
                    req.setHeader("Content-Length", request.Content.byteLength.toString());
                    req.write(Buffer.from(request.Content));
                }
                req.end();
            });
        }
        const arrivedAt = Date.now();
        logger_1.logger.info(`Received request from: '${request.HttpMethod} ${request.Url} ${request.Content?.byteLength ?? 0}`);
        const url = new URL(new URL(request.Url).pathname, this._options.target);
        logger_1.logger.info(`Proxied request to ${getDisplayUrl(url)}`);
        if (options?.handleProxiedRequest) {
            return await options.handleProxiedRequest(request, arrivedAt, url, () => httpInvoke(url, request, abortSignal));
        }
        else
            return await httpInvoke(url, request, abortSignal);
    }
}
exports.HttpServerProxy = HttpServerProxy;
