"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TunnelConnection = void 0;
const WebPubSubTunnelClient_1 = require("./WebPubSubTunnelClient");
const messages_1 = require("./messages");
const utils_1 = require("../utils");
const logger_1 = require("../logger");
const logger = (0, logger_1.createLogger)("TunnelConnection");
class TunnelConnection {
    endpoint;
    credential;
    hub;
    requestHandler;
    reverseProxyEndpoint;
    id = utils_1.Guid.newGuid();
    _ackMap = new Map();
    clients = new Map();
    lifetimeTcs = new utils_1.PromiseCompletionSource();
    _stopped = false;
    _ackId = 0;
    _keyMapping = new Map();
    constructor(endpoint, credential, hub, requestHandler, reverseProxyEndpoint) {
        this.endpoint = endpoint;
        this.credential = credential;
        this.hub = hub;
        this.requestHandler = requestHandler;
        this.reverseProxyEndpoint = reverseProxyEndpoint;
    }
    nextAckId() {
        this._ackId = this._ackId + 1;
        return this._ackId;
    }
    async runAsync(shouldRetry, abortSignal) {
        // Run the connection
        this._stopped = false;
        await this.startConnectionAsync({
            endpoint: this.endpoint,
            reverseProxyEndpoint: this.reverseProxyEndpoint,
        }, shouldRetry, abortSignal);
    }
    async invokeAsync(httpRequest, abortSignal, consistentKey) {
        const client = this.getClient(consistentKey);
        if (!client) {
            throw new Error("No connection available.");
        }
        const ackId = this.nextAckId();
        const pcs = new utils_1.PromiseCompletionSource();
        let firstResponse = false;
        let ackMap = this._ackMap;
        let body = new utils_1.AsyncIterator();
        let ackEntity = new utils_1.AckEntity(ackId, (data, error, done) => {
            // handle body
            if (error) {
                body.error(error);
            }
            if (data.Content) {
                body.add(data.Content);
            }
            if (done) {
                body.close();
            }
            if (!firstResponse) {
                firstResponse = true;
                if (consistentKey) {
                    this.releaseClient(consistentKey, client.id);
                }
                pcs.resolve({
                    statusCode: data.StatusCode,
                    body: body,
                });
            }
        }, abortSignal);
        ackMap.set(ackId, ackEntity);
        try {
            if (consistentKey) {
                this.lockClient(consistentKey, client);
            }
            let headers = {};
            if (httpRequest.contentType) {
                headers = { "Content-Type": [httpRequest.contentType] };
            }
            await client.sendAsync(new messages_1.TunnelHttpRequestMessage(ackId, true, "", httpRequest.method, httpRequest.url, headers, httpRequest.content), abortSignal);
            logger.info(`Sent http request: ackId: ${ackId}, method: ${httpRequest.method}, url: ${httpRequest.url}, hub: ${this.hub}`);
            // Wait for the first response which contains status code / headers
            return pcs.promise;
        }
        catch (err) {
            this._ackMap.delete(ackId);
            if (consistentKey) {
                this.releaseClient(consistentKey, client.id);
            }
            throw err;
        }
    }
    stop() {
        logger.warning(`Stop the lifetime. Start to close all connections, hub: ${this.hub}`);
        if (this._stopped) {
            return;
        }
        this._stopped = true;
        // Stop the connection
        this.lifetimeTcs.resolve();
        this.clients.forEach((element) => {
            this.stopConnection(element.id);
        });
    }
    getRandomKey() {
        const keys = Array.from(this.clients.keys());
        if (keys.length === 0) {
            return undefined;
        }
        return keys[Math.floor(Math.random() * keys.length)];
    }
    getClient(key) {
        if (key) {
            const tuple = this._keyMapping.get(key);
            if (tuple && tuple.client.stopped) {
                this._keyMapping.delete(key);
            }
            return tuple?.client || this.getRandomClient();
        }
        return this.getRandomClient();
    }
    getRandomClient() {
        let client;
        let i = 0;
        do {
            const key = this.getRandomKey();
            if (!key)
                return undefined;
            client = this.clients.get(key);
            i++;
        } while (i <= 5 && (!client || client.stopped));
        return client;
    }
    lockClient(key, client) {
        let tuple = this._keyMapping.get(key);
        if (tuple) {
            tuple = { count: tuple.count + 1, client };
        }
        else {
            tuple = { count: 1, client };
        }
        this._keyMapping.set(key, tuple);
    }
    releaseClient(key, clientId) {
        let tuple = this._keyMapping.get(key);
        if (!tuple || tuple.client.id != clientId) {
            return;
        }
        let newCount = tuple.count - 1;
        if (newCount === 0) {
            this._keyMapping.delete(key);
        }
        else {
            this._keyMapping.set(key, { count: newCount, client: tuple.client });
        }
    }
    async processMessage(client, message, abortSignal) {
        try {
            switch (message.Type) {
                case messages_1.TunnelMessageType.HttpResponse: {
                    const tunnelResponse = message;
                    logger.info(`Getting http response ${tunnelResponse.TracingId ?? ""}: ackId: ${tunnelResponse.AckId}, statusCode: ${tunnelResponse.StatusCode}, notComplete: ${tunnelResponse.NotCompleted}, hub: ${this.hub}`);
                    const ackId = tunnelResponse.AckId;
                    if (this._ackMap.has(ackId)) {
                        const entity = this._ackMap.get(ackId);
                        entity.write(tunnelResponse, null, !tunnelResponse.NotCompleted);
                        if (!tunnelResponse.NotCompleted) {
                            this._ackMap.delete(ackId);
                        }
                    }
                    break;
                }
                case messages_1.TunnelMessageType.HttpRequest: {
                    const tunnelRequest = message;
                    logger.info(`Getting http request ${tunnelRequest.TracingId ?? ""}: ackId: ${tunnelRequest.AckId}, method: ${tunnelRequest.HttpMethod}, url: ${tunnelRequest.Url}, hub: ${this.hub}`);
                    if (!this.requestHandler) {
                        throw new Error("Request handler not configured");
                    }
                    const response = await this.requestHandler(tunnelRequest, abortSignal);
                    if (response) {
                        logger.info(`Sending response back ${tunnelRequest.TracingId ?? ""}: ackId:${tunnelRequest.AckId}, statusCode: ${response.StatusCode}, content-length: ${response.Content.length}, hub: ${this.hub}`);
                        await client.sendAsync(new messages_1.TunnelHttpResponseMessage(tunnelRequest.AckId, tunnelRequest.LocalRouting, response.StatusCode, tunnelRequest.ChannelName, false, response.Headers, response.Content), abortSignal);
                    }
                    break;
                }
                case messages_1.TunnelMessageType.ConnectionReconnect: {
                    const reconnect = message;
                    logger.info(`Reconnect the connection ${client.getPrintableIdentifier()}: ${reconnect.Message}, hub: ${this.hub}`);
                    await this.stopConnection(client.id);
                    await this.startConnectionAsync({
                        endpoint: reconnect.Endpoint,
                        target: reconnect.TargetId,
                    }, () => true, // keep it retry forever
                    abortSignal);
                    break;
                }
                case messages_1.TunnelMessageType.ConnectionClose: {
                    const close = message;
                    logger.info(`Close the connection ${client.getPrintableIdentifier()}: ${close.Message}, hub: ${this.hub}`);
                    this.stopConnection(client.id);
                    break;
                }
                case messages_1.TunnelMessageType.ConnectionRebalance: {
                    const rebalance = message;
                    logger.info(`Start another rebalance connection ${rebalance.Endpoint} -> ${rebalance.TargetId}, via connection: ${client.getPrintableIdentifier()}, hub: ${this.hub}`);
                    await this.startConnectionAsync({
                        endpoint: rebalance.Endpoint,
                        target: rebalance.TargetId,
                    }, () => true, // retry forever to be consistent with current logic
                    abortSignal);
                    break;
                }
                default: {
                    logger.info(`[TunnelConnection] Not Support TBD message type: ${message.Type}, hub: ${this.hub}`);
                    break;
                }
            }
        }
        catch (err) {
            logger.warning(`Error processing message: ${err}, hub: ${this.hub}`);
        }
    }
    stopConnection(id) {
        logger.warning(`Stopping connection: ${id}, hub: ${this.hub}`);
        this.clients.get(id)?.stop();
    }
    async startConnectionAsync(target, shouldRetry, abortSignal) {
        if (this._stopped) {
            throw new Error(`Lifetime has stopped, hub: ${this.hub}`);
        }
        const url = this.getUrl(target, this.hub);
        const client = new WebPubSubTunnelClient_1.WebPubSubTunnelClient(url, this.credential, this.id, target.target);
        logger.info(`Starting connection: ${client.id}, hub: ${this.hub}`);
        client.on("stop", () => {
            logger.warning(`Client ${client.getPrintableIdentifier()} stopped, hub: ${this.hub}`);
            this.tryEndLife(client.id);
        });
        client.on("message", () => {
            while (client.messageQueue.length > 0) {
                const message = client.messageQueue.shift();
                if (message) {
                    this.processMessage(client, message, abortSignal);
                }
            }
        });
        this.clients.set(client.id, client);
        let retryAttempt = 0;
        let retry = false;
        do {
            if (abortSignal?.aborted || this._stopped) {
                throw new Error(`Stop starting new client for aborted or stopped`);
            }
            try {
                await client.startAsync(abortSignal);
                logger.info(`Connected connections: (${this.clients.size})\n` + Array.from(this.printClientLines()).join("\n"));
                return client.id;
            }
            catch (err) {
                retryAttempt++;
                retry = shouldRetry !== undefined && shouldRetry(err, retryAttempt);
                if (retry) {
                    logger.info(`Error starting client ${client.getPrintableIdentifier()}: ${err}, retry ${retryAttempt} in 2 seconds, hub: ${this.hub}`);
                    await delay(2000);
                }
                else {
                    throw err;
                }
            }
        } while (retry);
        throw "Unexpected";
    }
    tryEndLife(clientId) {
        if (this.clients.get(clientId)?.stopped) {
            this.clients.delete(clientId);
        }
        if (this.clients.size === 0) {
            this.lifetimeTcs.resolve();
        }
    }
    *printClientLines() {
        for (const [clientId, client] of this.clients) {
            yield `${client.getPrintableIdentifier()}: connectionId: ${client.currentConnectionId}; userId: ${client.userId}; ended: ${client.stopped}; target: ${client.target ?? "<random>"}; `;
        }
    }
    getUrl(target, hub) {
        const HttpTunnelPath = "server/tunnel";
        let endpoint;
        if (target.endpoint) {
            endpoint = target.endpoint;
        }
        else {
            logger.info(`No endpoint specified, use original endpoint ${this.endpoint}`);
            endpoint = this.endpoint;
        }
        const uriBuilder = new URL(endpoint);
        uriBuilder.protocol = uriBuilder.protocol.toLowerCase() === "http:" ? "ws:" : "wss:";
        uriBuilder.pathname = appendPath(uriBuilder.pathname, HttpTunnelPath);
        const hubQuery = `hub=${encodeURIComponent(hub)}`;
        if (!uriBuilder.search) {
            uriBuilder.search = `?${hubQuery}`;
        }
        else {
            uriBuilder.search = `${uriBuilder.search}&${hubQuery}`;
        }
        if (target.target) {
            uriBuilder.search = `${uriBuilder.search}&target=${encodeURIComponent(target.target)}`;
        }
        let reverseProxy = undefined;
        if (target.reverseProxyEndpoint) {
            reverseProxy = new URL(target.reverseProxyEndpoint);
            reverseProxy.protocol = reverseProxy.protocol.toLowerCase() === "http:" ? "ws:" : "wss:";
            reverseProxy.pathname = appendPath(reverseProxy.pathname, HttpTunnelPath);
            reverseProxy.search = uriBuilder.search;
        }
        return { endpoint: uriBuilder, reverseProxyEndpoint: reverseProxy };
    }
}
exports.TunnelConnection = TunnelConnection;
function delay(milliseconds) {
    return new Promise((resolve) => setTimeout(resolve, milliseconds));
}
function appendPath(pathname, append) {
    return pathname.endsWith("/") ? `${pathname}${append}` : `${pathname}/${append}`;
}
