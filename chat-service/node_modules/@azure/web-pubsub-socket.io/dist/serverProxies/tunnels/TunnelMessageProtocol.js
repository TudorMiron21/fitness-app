"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TunnelMessageProtocol = void 0;
const msgpack_1 = require("@msgpack/msgpack");
const messages_1 = require("./messages");
class TunnelMessageProtocol {
    static messageLengthSize = 4;
    static maxLength = 1024 * 1024; // 1M
    static instance = new TunnelMessageProtocol();
    getBytes(message) {
        let content = undefined;
        if (message instanceof messages_1.TunnelByteContentMessage) {
            content = message.Content;
        }
        const bytes = [
            message.Type,
            JSON.stringify(message, (key, value) => {
                if (key === "Content") {
                    // exclude the byte Content
                    return undefined;
                }
                return value;
            }),
            content,
        ];
        const encodedMessage = (0, msgpack_1.encode)(bytes);
        const messageLength = encodedMessage.byteLength;
        const buffer = new ArrayBuffer(TunnelMessageProtocol.messageLengthSize + messageLength);
        const view = new DataView(buffer);
        view.setUint32(0, messageLength, true);
        const dataView = new Uint8Array(buffer);
        dataView.set(encodedMessage, TunnelMessageProtocol.messageLengthSize);
        return dataView;
    }
    parseMessage(data) {
        const lengthHeader = data.slice(0, 4);
        const view = new DataView(lengthHeader.buffer);
        const length = view.getInt32(0, true);
        const content = data.slice(4, length + 4);
        const array = (0, msgpack_1.decode)(content);
        const type = array[0];
        const json = array[1];
        const body = array[2];
        switch (type) {
            case messages_1.TunnelMessageType.HttpRequest:
                const request = JSON.parse(json);
                request.Content = body;
                return request;
            case messages_1.TunnelMessageType.HttpResponse:
                const response = JSON.parse(json);
                response.Content = body;
                return response;
            case messages_1.TunnelMessageType.ServiceStatus: {
                return JSON.parse(json);
            }
            case messages_1.TunnelMessageType.ConnectionReconnect: {
                return JSON.parse(json);
            }
            case messages_1.TunnelMessageType.ConnectionClose: {
                return JSON.parse(json);
            }
            case messages_1.TunnelMessageType.ConnectionConnected: {
                return JSON.parse(json);
            }
            case messages_1.TunnelMessageType.ConnectionRebalance: {
                return JSON.parse(json);
            }
            default: {
                return undefined;
            }
        }
    }
}
exports.TunnelMessageProtocol = TunnelMessageProtocol;
