"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebPubSubTransport = void 0;
const utils_1 = require("../../common/utils");
const decoder_1 = require("../../SIO/components/decoder");
const constants_1 = require("./constants");
const engine_io_1 = require("engine.io");
const socket_io_parser_1 = require("socket.io-parser");
const debug = (0, utils_1.debugModule)("wps-sio-ext:EIO:WebPubSubTransport");
/**
 * A class inherited from Engine.IO Transport class, it plays the same role as `Polling` Transport and `WebSocket` Transport.
 * Similar with `Polling`, this transport always does batch send (send mulitple packets at once) and batch receive.
 * Reference: https://github.com/socketio/engine.io/tree/6.4.2/lib/transports
 **/
class WebPubSubTransport extends engine_io_1.Transport {
    clientConnectionContext;
    // Reference: https://github.com/socketio/engine.io-parser/blob/5.0.7/lib/encodePacket.ts#L3
    _encodeEioPacketAsync;
    // Reference: https://github.com/socketio/engine.io-parser/blob/5.0.7/lib/index.ts#L7
    _encodeEioPayloadAsync;
    /**
     * Indicate whether any packet have been actually sent through AWPS or not.
     */
    _opened;
    /**
     * A buffer to store packets which are waiting to be sent designed for resolving SIO binary attachments problem.
     */
    _buffer = [];
    /**
     * Indicate whether the transport is underlying Socket.IO or a pure Engine.IO transport.
     */
    _sioMode;
    constructor(req, sioMode = true) {
        debug("constructor");
        super(req);
        this.clientConnectionContext = req[constants_1.WEBPUBSUB_CLIENT_CONNECTION_FILED_NAME];
        this._opened = false;
        // `Socket` places packets in its own buffer if `writable` == false. Otherwise, it calls `send` with buffer directly.
        // Reference: https://github.com/socketio/engine.io/blob/6.4.2/lib/socket.ts#L510
        this.writable = true;
        this._sioMode = sioMode;
        this._encodeEioPacketAsync = (0, utils_1.toAsync)(this.parser.encodePacket);
        this._encodeEioPayloadAsync = (0, utils_1.toAsync)(this.parser.encodePayload);
    }
    supportsFraming = () => false;
    name = () => constants_1.WEBPUBSUB_TRANSPORT_NAME;
    /**
     * sends an array of `Packet` to the client.
     * @param packets - An array of `Packet` to send
     */
    async send(packets) {
        debug(`send packets, packets.length = ${packets.length}, packets = ${JSON.stringify(packets)},\
_buffer.length=${this._buffer.length}, _buffer=${JSON.stringify(this._buffer)}`);
        this.writable = false;
        this._buffer.push(...packets);
        packets = [];
        if (this._buffer.length > 0 && !this._opened) {
            const firstPacket = this._buffer.shift();
            if (firstPacket.type === "open") {
                const payload = await this._encodeEioPacketAsync(firstPacket, false);
                debug(`first packet is 'open' packet, payload = ${payload}`);
                this.clientConnectionContext.onAcceptEioConnection(payload.substring(1));
                this._opened = true;
            }
            else {
                const errorMessage = `First packet must be a valid packet whose type is 'open', got packet = ${firstPacket}.`;
                debug(errorMessage);
                this.clientConnectionContext.onRefuseEioConnection(errorMessage);
            }
        }
        while (this._buffer.length > 0) {
            let sentNumber = 0;
            try {
                sentNumber = this._getPacketNumberForNextSend(this._buffer);
            }
            catch (error) {
                debug(`send, internal error, inside _getPacketNumberForNextSend, error = ${error.message},\
_buffer=${JSON.stringify(this._buffer)}`);
                sentNumber = this._buffer.length;
            }
            if (sentNumber <= 0)
                break;
            const payloads = await this._encodeEioPayloadAsync(this._buffer.splice(0, sentNumber));
            await this._webPubSubSend(payloads);
        }
        this.writable = true;
        // Transport's event `drain` is binded to `flush` method in `Socket` class by its father socket.
        debug(`send, emit drain`);
        this.emit("drain");
        debug(`send, finish, _buffer.length=${this._buffer.length}, _buffer=${JSON.stringify(this._buffer)}`);
    }
    doClose(fn) {
        debug("close");
        this.send([{ type: "close" }]);
        if (fn) {
            fn();
        }
    }
    onClose() {
        debug("onClose");
        super.onClose();
    }
    /**
     * Send `data` to client via AWPS asynchronously.
     * @param data - The data to be sent.
     * @param autoRetry - If true, wait for a certain time and retry sending when the first response status is 429.
     */
    async _webPubSubSend(data, autoRetry = false) {
        debug(`webPubSubSend ${data}`);
        try {
            await this.clientConnectionContext.send(data);
        }
        catch (error) {
            debug(error);
            if (autoRetry && error.response && error.response.status === 429) {
                const retryAfterSeconds = error.response.headers.get("retry-after");
                await new Promise((resolve) => setTimeout(resolve, retryAfterSeconds * 1000));
                await this.clientConnectionContext.send(data);
            }
            else {
                throw error;
            }
        }
        debug(`webPubSubSend, finish`);
    }
    _isMessageWithBinary(packet) {
        return packet.data instanceof ArrayBuffer || ArrayBuffer.isView(packet.data);
    }
    _isTypeWithBinary(packet) {
        return packet.type === socket_io_parser_1.PacketType.BINARY_EVENT || packet.type === socket_io_parser_1.PacketType.BINARY_ACK;
    }
    /**
     * For SIO mode:
     *  returns the largest `n` satisfying `packets[0 .. n - 1]` doesn't contain any incomplete binary-related EIO packet sequence.
     *  A complete binary-related EIO packet sequence = [BINARY_EVENT/BINARY_ACK SIO payload, ...(all its binary attachments)]
     * For EIO mode:
     *  The number of binary attachments cannot be inferred. This method returns `packets.length` directly.
     * @param packets - EIO packets
     * @returns the number of packets that can be sent in the next REST API call
     */
    _getPacketNumberForNextSend(packets) {
        if (!this._sioMode)
            return packets.length;
        /**
         * Binary Packet = an EIO packet whose data is BINARY_EVENT or BINARY_ACK SIO packet.
         * Binary Attachment Packet = an EIO packet whose data is binary attachment of a binary packet.
         */
        let attachmentCount = 0, // the number of binary attachment packets found for the latest binary packet.
        expectedAttachments = 0, // the expected number of binary attachment packets for the latest binary packet.
        lastBinaryMessagePacketIdx = -1, // the index of the latest binary packet.
        lastSentPacketIdx = -1, // the largest index of EIO packet that can be sent in the next REST API call
        shouldBeAttachment = false; // whether the current packet should be a binary attachment packet
        for (let i = 0; i < packets.length; i++) {
            const eioPacket = packets[i];
            // Condition 0: a pure EIO packet without data related to SIO packet.
            if (eioPacket.type !== "message") {
                lastSentPacketIdx++;
                continue;
            }
            // Condition 1: A binary attachment packet
            if (this._isMessageWithBinary(eioPacket)) {
                if (!shouldBeAttachment)
                    throw new Error(`Expect a packet whose data is binary attachment but not found, packets[${i}] = ${eioPacket}`);
                attachmentCount++;
                if (attachmentCount === expectedAttachments) {
                    if (lastBinaryMessagePacketIdx < 0 || lastBinaryMessagePacketIdx >= i)
                        throw new Error(`Invalid lastBinaryMessagePacketIdx = ${lastBinaryMessagePacketIdx}, packets[${i}] = ${eioPacket}`);
                    attachmentCount = 0;
                    shouldBeAttachment = false;
                    lastSentPacketIdx = i;
                }
                else {
                    shouldBeAttachment = true;
                }
                continue;
            }
            const sioPacket = (0, decoder_1.decodeStringPartial)(eioPacket.data);
            // Condition 2: A binary packet
            if (this._isTypeWithBinary(sioPacket)) {
                if (shouldBeAttachment)
                    throw new Error(`Expect a packet with binary content, but got a regular packet, packets[${i}] = ${eioPacket}`);
                if (attachmentCount !== 0)
                    throw new Error(`Exepect attachmentCount = 0 but got ${attachmentCount}, packets[${i}] = ${eioPacket}`);
                attachmentCount = 0;
                expectedAttachments = sioPacket.attachments;
                lastBinaryMessagePacketIdx = i;
                shouldBeAttachment = true;
                continue;
            }
            // Condition 3: A EIO packet whose data is related to SIO packet. But it is neither a binary packet nor a binary attachment packet
            if (shouldBeAttachment) {
                throw new Error(`Expect a packet whose data is binary attachment but not found, packets[${i}] = ${eioPacket}`);
            }
            shouldBeAttachment = false;
            lastSentPacketIdx++;
        }
        return lastSentPacketIdx + 1;
    }
}
exports.WebPubSubTransport = WebPubSubTransport;
//# sourceMappingURL=web-pubsub-transport.js.map