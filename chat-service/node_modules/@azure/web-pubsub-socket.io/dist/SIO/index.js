"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebPubSubAdapterProxy = exports.useAzureSocketIO = exports.useAzureSocketIOChain = void 0;
const utils_1 = require("../common/utils");
const EIO_1 = require("../EIO");
const web_pubsub_adapter_1 = require("./components/web-pubsub-adapter");
Object.defineProperty(exports, "WebPubSubAdapterProxy", { enumerable: true, get: function () { return web_pubsub_adapter_1.WebPubSubAdapterProxy; } });
const constants_1 = require("./components/constants");
const negotiate_1 = require("./components/negotiate");
const debug = (0, utils_1.debugModule)("wps-sio-ext:SIO:index");
debug("load");
async function useAzureSocketIOChain(webPubSubOptions) {
    debug(`useAzureSocketIOChain, webPubSubOptions: ${JSON.stringify(webPubSubOptions)}`);
    const engine = new EIO_1.WebPubSubEioServer(this.engine.opts, webPubSubOptions);
    const httpServer = this["httpServer"];
    engine.attach(httpServer, this["opts"]);
    // Add negotiate handler
    debug("add negotiate handler");
    const path = this._opts.path || constants_1.DEFAULT_SIO_PATH;
    // current listeners = EIO handleRequest listeners (e.g. /socket.io) + other listeners from user
    const listeners = httpServer.listeners("request").slice(0);
    httpServer.removeAllListeners("request");
    this[constants_1.WEB_PUBSUB_OPTIONS_PROPERY_NAME] = webPubSubOptions;
    httpServer.on("request", (req, res) => {
        // Requests routing to EIO `handleRequest` listener should be forbidden. Other listeners should be handled as normal.
        for (let i = 0; i < listeners.length; i++) {
            // Follow the same logic as Engine.IO
            // Reference: https://github.com/socketio/engine.io/blob/6.4.2/lib/server.ts#L804
            if (path !== req.url.slice(0, path.length)) {
                listeners[i].call(httpServer, req, res);
            }
            else {
                debug(`Forbidden request whose url ${req.url} starts with ${path}`);
                (0, utils_1.writeResponse)(res, 403, constants_1.FORBIDDEN_REQUEST_MESSAGE, "text/plain");
            }
        }
    });
    // `attachServe` is a Socket.IO design which attachs static file serving to internal http server.
    // Creating new engine makes previous `attachServe` execution invalid.
    // Reference: https://github.com/socketio/socket.io/blob/4.6.2/lib/index.ts#L518
    debug("serve static file");
    if (this["_serveClient"]) {
        this["attachServe"](httpServer);
    }
    this.bind(engine);
    debug("use webPubSub adatper");
    const adapterProxy = new web_pubsub_adapter_1.WebPubSubAdapterProxy(this.engine.webPubSubConnectionManager.service);
    this.adapter(adapterProxy);
    this.use((0, utils_1.getSioMiddlewareFromExpress)((0, negotiate_1.restoreClaims)()));
    // If using tunnel, wait until connected. `engine.setup` does no nothing when using REST API.
    await engine.setup();
    return this;
}
exports.useAzureSocketIOChain = useAzureSocketIOChain;
/**
 * This method returns a Socket.IO server using Web PubSub for Socket.IO.
 *
 * @param io - the Socket.IO server instance
 * @param azureSocketIOOptions - the options of Web PubSub for Socket.IO
 * @returns a Socket.IO server instance using Web PubSub for Socket.IO
 *
 * @public
 */
async function useAzureSocketIO(io, azureSocketIOOptions) {
    debug(`useAzureSocketIO, azureSocketIOOptions: ${JSON.stringify(azureSocketIOOptions)}`);
    return useAzureSocketIOChain.call(io, azureSocketIOOptions);
}
exports.useAzureSocketIO = useAzureSocketIO;
//# sourceMappingURL=index.js.map