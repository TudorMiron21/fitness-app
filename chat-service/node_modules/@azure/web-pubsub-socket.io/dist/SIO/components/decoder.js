"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeStringPartial = void 0;
const utils_1 = require("../../common/utils");
const socket_io_parser_1 = require("socket.io-parser");
const debug = (0, utils_1.debugModule)("wps-sio-ext:SIO:Decoder");
/**
 * Decode a packet String partially(JSON data). Only type and the number of attachements are decoded.
 * Modified from https://github.com/socketio/socket.io-parser/blob/4.2.4/lib/index.ts#L210
 *
 * @param {String} str - target string
 * @return {Object} packet
 */
function decodeStringPartial(str) {
    let i = 0;
    // look up type
    const p = {
        type: Number(str.charAt(0)),
        attachments: 0,
    };
    if (socket_io_parser_1.PacketType[p.type] === undefined) {
        throw new Error("unknown packet type " + p.type);
    }
    // look up attachments if type binary
    if (p.type === socket_io_parser_1.PacketType.BINARY_EVENT || p.type === socket_io_parser_1.PacketType.BINARY_ACK) {
        const start = i + 1;
        // eslint-disable-next-line no-empty
        while (str.charAt(++i) !== "-" && i != str.length) { }
        const buf = str.substring(start, i);
        // Native implementation is `buf != Number(buf) || ...`. Modify it to pass typescript compilation check
        if (buf !== Number(buf).toString() || str.charAt(i) !== "-") {
            throw new Error("Illegal attachments");
        }
        p.attachments = Number(buf);
    }
    // Skip decoding `p.namespace`, `p.id` and `p.data`
    debug("decoded %s as %j", str, p);
    return p;
}
exports.decodeStringPartial = decodeStringPartial;
//# sourceMappingURL=decoder.js.map