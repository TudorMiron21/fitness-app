"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebPubSubAdapterInternal = exports.WebPubSubAdapterProxy = void 0;
const utils_1 = require("../../common/utils");
const encoder_1 = require("./encoder");
const socket_io_parser_1 = require("socket.io-parser");
const EioParser = __importStar(require("engine.io-parser"));
const socket_io_adapter_1 = require("socket.io-adapter");
const async_mutex_1 = require("async-mutex");
const base64url_1 = __importDefault(require("base64url"));
const util_1 = require("util");
const debug = (0, utils_1.debugModule)("wps-sio-ext:SIO:Adapter");
const GROUP_DELIMITER = "~";
/**
 * Socket.IO Server uses method `io.Adapter(AdapterClass))` to set the adapter. `AdatperClass` is not an instansized object, but a class.
 * The actual adapter is instansized inside server logic.
 * Thus its constructor parameters of the adapter class is out of our control.
 * So a proxy class is necessary to wrap the adapter class for customimzed constructor parameters.
 * How to use:
 *  1. Instansize a `WebPubSubAdapterProxy` object: `const webPubSubAdapterProxy = new WebPubSubAdapterProxy(extraOptions);`
 *  2. Set the adapter: `io.adapter(WebPubSubAdapterProxy);`, thus additional options are controllable.
 */
class WebPubSubAdapterProxy {
    serivce;
    sioServer;
    constructor(serviceClient) {
        this.serivce = serviceClient;
        const proxyHandler = {
            construct: (target, args) => new target(...args, serviceClient),
        };
        return new Proxy(WebPubSubAdapterInternal, proxyHandler);
    }
}
exports.WebPubSubAdapterProxy = WebPubSubAdapterProxy;
class WebPubSubAdapterInternal extends socket_io_adapter_1.Adapter {
    nsp;
    service;
    _roomOperationLock = new Map();
    _sioDecoder;
    _utf8Decoder = new util_1.TextDecoder("utf-8");
    /**
     * Azure Web PubSub Socket.IO Adapter constructor.
     *
     * @param nsp - Namespace
     * @param extraArgForWpsAdapter - extra argument for WebPubSubAdapter
     */
    constructor(nsp, serviceClient) {
        debug(`constructor nsp.name = ${nsp.name}, serviceClient = ${serviceClient}`);
        super(nsp);
        this.nsp = nsp;
        this.service = serviceClient;
        this._sioDecoder = new socket_io_parser_1.Decoder();
    }
    /**
     * Broadcasts a packet.
     *
     * @param packet - the packet object
     * @param opts - the options
     */
    async broadcast(packet, opts) {
        debug(`broadcast, start, packet = ${JSON.stringify(packet)},\
opts = ${(0, utils_1.toOptionsString)(opts)}, namespace = "${this.nsp.name}"`);
        try {
            packet.nsp = this.nsp.name;
            // Although here's a await, but this method actually return in sync
            const encodedPayload = await (0, encoder_1.getSingleEioEncodedPayload)(packet);
            // optimize
            if (opts.rooms.size === 1) {
                const oDataFilter = this._buildODataFilterForExceptsOnly(opts.except);
                const sendOptions = { filter: oDataFilter, contentType: "text/plain" };
                debug(`broadcast, encodedPayload = "${encodedPayload}", sendOptions = "${JSON.stringify(sendOptions)}"`);
                const encodedGroupName = this._getGroupName(this.nsp.name, opts.rooms.values().next().value);
                await this.service.group(encodedGroupName).sendToAll(encodedPayload, sendOptions);
                debug(`broadcast, finish`);
            }
            else {
                const oDataFilter = this._buildODataFilter(opts.rooms, opts.except);
                const sendOptions = { filter: oDataFilter, contentType: "text/plain" };
                debug(`broadcast, encodedPayload = "${encodedPayload}", sendOptions = "${JSON.stringify(sendOptions)}"`);
                await this.service.sendToAll(encodedPayload, sendOptions);
                debug(`broadcast, finish`);
            }
        }
        catch (e) {
            debug(`broadcast, error, packet = ${JSON.stringify(packet)},\
opts = ${(0, utils_1.toOptionsString)(opts)}, namespace = "${this.nsp.name}", error = ${e}`);
        }
    }
    /**
     * Makes the matching socket instances join the specified rooms
     *
     * @param opts - the filters to apply
     * @param rooms - the rooms to join
     */
    async addSockets(opts, rooms) {
        debug(`addSockets, start, rooms = ${(0, utils_1.toString)(rooms)}, opts = ${(0, utils_1.toOptionsString)(opts)}`);
        try {
            const oDataFilter = this._buildODataFilter(opts.rooms, opts.except);
            const groupNames = Array.from(rooms).map((room) => this._getGroupName(this.nsp.name, room));
            await this.service.addConnectionsToGroups(groupNames, oDataFilter);
            debug(`addSockets, call API addConnectionsToGroups, finish, \
rooms = ${(0, utils_1.toString)(rooms)}, opts = ${(0, utils_1.toOptionsString)(opts)}`);
            super.addSockets(opts, rooms);
        }
        catch (e) {
            debug(`addSockets, error, rooms = ${(0, utils_1.toString)(rooms)}, opts = ${(0, utils_1.toOptionsString)(opts)}, \
error.message = ${e.message}, error = ${e}`);
        }
    }
    /**
     * Adds a socket to a list of room.
     *
     * @param id - the socket id
     * @param rooms - a set of rooms
     */
    async addAll(id, rooms) {
        debug(`addAll, start, id = ${id}, rooms = ${(0, utils_1.toString)(rooms)}}`);
        const release = await this._getLock(id);
        try {
            const eioSid = this._getEioSid(id);
            const connectionFilter = `connectionId eq '${eioSid}'`;
            const groupNames = Array.from(rooms).map((room) => this._getGroupName(this.nsp.name, room));
            debug(`addAll, connectionFilter = "${connectionFilter}", groupNames = "${(0, utils_1.toString)(groupNames)}"`);
            await this.service.addConnectionsToGroups(groupNames, connectionFilter);
            debug(`addAll, call API AddConnectionsToGroups, finish, \
groupNames = ${(0, utils_1.toString)(rooms)}, connectionId(eioSid) = ${this._getEioSid(id)}`);
            super.addAll(id, rooms);
        }
        catch (e) {
            debug(`addAll, error, SocketId = ${id}, rooms = ${(0, utils_1.toString)(rooms)}, error = ${e}`);
        }
        finally {
            release();
        }
        debug(`addAll, finish, SocketId = ${id}, rooms = ${(0, utils_1.toString)(rooms)}, id.rooms = ${(0, utils_1.toString)(this.sids.get(id))}`);
    }
    /**
     * Removes a socket from a room.
     *
     * @param id - the socket id
     * @param room - the room name
     */
    async del(id, room) {
        debug(`del, start, id = ${id}, room = ${room}`);
        const release = await this._getLock(id);
        try {
            const eioSid = this._getEioSid(id);
            const groupName = this._getGroupName(this.nsp.name, room);
            await this.service.group(groupName).removeConnection(eioSid);
            debug(`del, call API RemoveConnectionFromGroup, finish, groupName = ${groupName}, connectionId(eioSid) = ${eioSid}`);
            super.del(id, room);
        }
        catch (e) {
            debug(`del, error, SocketId = ${id}, room = ${room}, error = ${e}`);
        }
        finally {
            release();
        }
        debug(`del, finish, SocketId = ${id}, room = ${room}, id.rooms = ${(0, utils_1.toString)(this.sids.get(id))}`);
    }
    /**
     * Removes a socket from all rooms it's joined.
     *
     * @param id - the socket id
     */
    async delAll(id) {
        debug(`delAll, start, id = ${id}`);
        const release = await this._getLock(id);
        debug(`delAll, lock acquired`);
        try {
            // send disconnect packet to socketio connection by leveraging private room whose name == sid
            const packet = { type: socket_io_parser_1.PacketType.DISCONNECT };
            const opts = { rooms: new Set([id]) };
            debug(`delAll, call adapter.broadcast`);
            await this.broadcast(packet, opts);
            super.delAll(id);
        }
        catch (e) {
            debug(`delAll, error, SocketId = ${id}, error = ${e}`);
        }
        finally {
            release();
        }
        debug(`delAll, finish, SocketId = ${id}, id.rooms = ${(0, utils_1.toString)(this.sids.get(id))}`);
    }
    /**
     * Broadcasts a packet and expects multiple acknowledgements.
     *
     * @param packet - the packet object
     * @param opts - the options
     * @param clientCountCallback - the number of clients that received the packet
     * @param ack - the callback that will be called for each client response
     */
    async broadcastWithAck(packet, opts, clientCountCallback, ack) {
        debug(`broadcastWithAck, start, packet = ${JSON.stringify(packet)},\
  opts = ${(0, utils_1.toOptionsString)(opts)}, namespace = "${this.nsp.name}"`);
        let accumulatedData = "";
        let count = 0;
        const streamHandleResponse = (chunk) => {
            const handleJsonLines = (lines, onPacket) => {
                /**
                 * Line 1: {xxx}
                 * Line 2: {xxx}
                 * ..
                 * Line N: {xx   // maybe not complete
                 */
                for (let i = 0; i < lines.length - 1; i++) {
                    if (lines[i]) {
                        const emitWithAckResponse = JSON.parse(lines[i]);
                        // The payload is UTF-8 encoded EIO payload, we need to decode it and only ack the data
                        const eioPackets = EioParser.decodePayload(emitWithAckResponse.Payload);
                        this._sioDecoder.on("decoded", (packet) => onPacket(packet));
                        eioPackets.forEach((element) => {
                            this._sioDecoder.add(element.data);
                        });
                        this._sioDecoder.off("decoded");
                    }
                }
            };
            accumulatedData += chunk.toString();
            const lines = accumulatedData.split("\n");
            handleJsonLines(lines, (packet) => {
                ack(...packet.data);
                count++;
            });
            accumulatedData = lines[lines.length - 1];
        };
        const bodyHandler = (value, end) => {
            if (value) {
                const text = this._utf8Decoder.decode(value);
                streamHandleResponse(text);
            }
            if (end) {
                clientCountCallback(count);
                return;
            }
        };
        try {
            packet.nsp = this.nsp.name;
            const encodedPayload = await (0, encoder_1.getSingleEioEncodedPayload)(packet);
            const oDataFilter = this._buildODataFilter(opts.rooms, opts.except);
            await this.service.invoke(encodedPayload, bodyHandler, { filter: oDataFilter, contentType: "text/plain" });
            debug(`broadcastWithAck, finish`);
        }
        catch (e) {
            debug(`broadcastWithAck, error, packet = ${JSON.stringify(packet)},\
opts = ${(0, utils_1.toOptionsString)(opts)}, namespace = "${this.nsp.name}, error = ${e}"`);
        }
    }
    /**
     * Gets a list of sockets by sid.
     *
     * @param _rooms - the explicit set of rooms to check.
     */
    sockets(_rooms) {
        throw new Error(`'sockets' is not supported.`);
    }
    /**
     * Gets the list of rooms a given socket has joined.
     *
     * @param id - the socket id
     */
    socketRooms(id) {
        debug(`socketRooms, start, id = ${id}`);
        // Follow the same handling logic as RedisAdapter. Though it's incorrect strictly for multiple server condition.
        const ret = super.socketRooms(id);
        debug(`socketRooms, finish, id = ${id} ${(0, utils_1.toString)(ret)}`);
        return ret;
    }
    /**
     * Returns the matching socket instances
     *
     * @param opts - the filters to apply
     */
    fetchSockets(opts) {
        debug(`fetchSockets, start, opts = ${(0, utils_1.toOptionsString)(opts)}`);
        if (opts.flags.local) {
            return super.fetchSockets(opts);
        }
        else {
            throw new Error(`'fetchSockets' without local flag is not supported`);
        }
    }
    /**
     * Makes the matching socket instances leave the specified rooms
     *
     * @param opts - the filters to apply
     * @param rooms - the rooms to leave
     */
    async delSockets(opts, rooms) {
        debug(`delSockets, start, rooms = ${(0, utils_1.toString)(rooms)}, opts = ${(0, utils_1.toOptionsString)(opts)}`);
        try {
            const oDataFilter = this._buildODataFilter(opts.rooms, opts.except);
            const groupNames = Array.from(rooms).map((room) => this._getGroupName(this.nsp.name, room));
            await this.service.removeConnectionsFromGroups(groupNames, oDataFilter);
            debug(`delSockets, call API removeConnectionsFromGroups, finish, \
rooms = ${(0, utils_1.toString)(rooms)}, opts = ${(0, utils_1.toOptionsString)(opts)}`);
            super.delSockets(opts, rooms);
        }
        catch (e) {
            debug(`delSockets, error, rooms = ${(0, utils_1.toString)(rooms)}, \
opts = ${(0, utils_1.toOptionsString)(opts)}, error = ${e}`);
        }
    }
    /**
     * Send a packet to the other Socket.IO servers in the cluster
     * @param _packet - an array of arguments, which may include an acknowledgement callback at the end
     */
    serverSideEmit(_packet) {
        throw new Error(`'serverSideEmit' is not supported.`);
    }
    /**
     * Makes the matching socket instances disconnect
     *
     * @param opts - the filters to apply
     * @param close - whether to close the underlying connection
     */
    async disconnectSockets(opts, close) {
        debug(`disconnectSockets, start, opts = ${(0, utils_1.toOptionsString)(opts)}, close = ${close}`);
        await this.broadcast({ type: socket_io_parser_1.PacketType.DISCONNECT, nsp: this.nsp.name, data: { close: close } }, opts);
        /**
         * Server should not call Socket.disconnect(close) for each socket as `super.disconnectSockets` does.
         * Server should wait for EIO CLOSE packet or SIO DISCONNECT packet sent from service.
         */
        debug(`disconnectSockets, finish, opts = ${(0, utils_1.toOptionsString)(opts)}, close = ${close}`);
    }
    /**
     * Generates OData filter string for Web PubSub service from a set of rooms and a set of exceptions
     * @param rooms - a set of Rooms to include
     * @param excepts - a set of Rooms to exclude
     * @returns OData - filter string
     */
    _buildODataFilter(rooms, excepts) {
        debug("_buildODataFilter");
        let allowFilter = "";
        let room_idx = 0, except_idx = 0;
        if (rooms.size === 0)
            rooms = new Set([""]);
        for (const room of rooms) {
            const groupName = this._getGroupName(this.nsp.name, room);
            allowFilter += `'${groupName}' in groups` + (room_idx === rooms.size - 1 ? "" : " or ");
            room_idx++;
        }
        let denyFilter = "";
        if (excepts) {
            for (const except of excepts) {
                const exceptGroupName = this._getGroupName(this.nsp.name, except);
                denyFilter += `not ('${exceptGroupName}' in groups)` + (except_idx === excepts.size - 1 ? "" : " and ");
                except_idx++;
            }
        }
        let result = "";
        if (allowFilter.length > 0) {
            result = allowFilter + (denyFilter.length > 0 ? " and " + denyFilter : "");
        }
        else
            result = denyFilter.length > 0 ? `${denyFilter}` : "";
        debug(`_buildODataFilter result = ${result}`);
        return result;
    }
    /**
     * Generates OData filter string for Web PubSub service from a set of exceptions
     * @param excepts - a set of Rooms to exclude
     * @returns OData - filter string
     */
    _buildODataFilterForExceptsOnly(excepts) {
        debug("_buildODataFilterForExceptsOnly");
        let except_idx = 0;
        let denyFilter = "";
        if (excepts) {
            for (const except of excepts) {
                const exceptGroupName = this._getGroupName(this.nsp.name, except);
                denyFilter += `not ('${exceptGroupName}' in groups)` + (except_idx === excepts.size - 1 ? "" : " and ");
                except_idx++;
            }
        }
        debug(`_buildODataFilterForExceptsOnly result = ${denyFilter}`);
        return denyFilter;
    }
    _getEioSid(sioSid) {
        debug(`Get EIO socket, id = "${sioSid}", nsp.sockets = ${(0, utils_1.toString)(this.nsp.sockets.keys())}`);
        return this.nsp.sockets.get(sioSid).conn["id"];
    }
    /**
     * `namespace` and `room` are concpets from Socket.IO.
     * `group` is a concept from Azure Web PubSub.
     */
    _getGroupName(namespace, room) {
        let ret = `0${GROUP_DELIMITER}${(0, base64url_1.default)(namespace)}${GROUP_DELIMITER}`;
        if (room && room.length > 0) {
            ret += (0, base64url_1.default)(room);
        }
        debug(`convert (ns="${namespace}", room="${room}") => groupName = "${ret}"`);
        return ret;
    }
    async _getLock(id) {
        debug(`_getLock, start, id = ${id}`);
        if (!this._roomOperationLock.has(id)) {
            this._roomOperationLock.set(id, new async_mutex_1.Mutex());
        }
        const lock = this._roomOperationLock.get(id);
        const release = await lock.acquire();
        debug(`_getLock, finish, id = ${id}`);
        return release;
    }
}
exports.WebPubSubAdapterInternal = WebPubSubAdapterInternal;
//# sourceMappingURL=web-pubsub-adapter.js.map