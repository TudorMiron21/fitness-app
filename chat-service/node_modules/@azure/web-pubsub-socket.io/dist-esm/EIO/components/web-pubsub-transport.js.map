{"version":3,"file":"web-pubsub-transport.js","sourceRoot":"","sources":["../../../src/EIO/components/web-pubsub-transport.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { debugModule, toAsync } from \"../../common/utils\";\nimport { ClientConnectionContext } from \"./client-connection-context\";\nimport { decodeStringPartial, PartialSioPacket } from \"../../SIO/components/decoder\";\nimport { WEBPUBSUB_CLIENT_CONNECTION_FILED_NAME, WEBPUBSUB_TRANSPORT_NAME } from \"./constants\";\nimport { Transport } from \"engine.io\";\nimport { Packet as EioPacket, RawData } from \"engine.io-parser\";\nimport { PacketType as SioPacketType } from \"socket.io-parser\";\n\nconst debug = debugModule(\"wps-sio-ext:EIO:WebPubSubTransport\");\n\n/**\n * A class inherited from Engine.IO Transport class, it plays the same role as `Polling` Transport and `WebSocket` Transport.\n * Similar with `Polling`, this transport always does batch send (send mulitple packets at once) and batch receive.\n * Reference: https://github.com/socketio/engine.io/tree/6.4.2/lib/transports\n **/\nexport class WebPubSubTransport extends Transport {\n  public clientConnectionContext: ClientConnectionContext;\n\n  // Reference: https://github.com/socketio/engine.io-parser/blob/5.0.7/lib/encodePacket.ts#L3\n  private _encodeEioPacketAsync: (packet: EioPacket, supportsBinary: boolean) => Promise<RawData>;\n  // Reference: https://github.com/socketio/engine.io-parser/blob/5.0.7/lib/index.ts#L7\n  private _encodeEioPayloadAsync: (packets: EioPacket[]) => Promise<string>;\n\n  /**\n   * Indicate whether any packet have been actually sent through AWPS or not.\n   */\n  private _opened: boolean;\n  /**\n   * A buffer to store packets which are waiting to be sent designed for resolving SIO binary attachments problem.\n   */\n  private _buffer: EioPacket[] = [];\n\n  /**\n   * Indicate whether the transport is underlying Socket.IO or a pure Engine.IO transport.\n   */\n  private _sioMode: boolean;\n\n  constructor(req: unknown, sioMode = true) {\n    debug(\"constructor\");\n    super(req);\n    this.clientConnectionContext = req[WEBPUBSUB_CLIENT_CONNECTION_FILED_NAME];\n    this._opened = false;\n\n    // `Socket` places packets in its own buffer if `writable` == false. Otherwise, it calls `send` with buffer directly.\n    // Reference: https://github.com/socketio/engine.io/blob/6.4.2/lib/socket.ts#L510\n    this.writable = true;\n    this._sioMode = sioMode;\n    this._encodeEioPacketAsync = toAsync<string>(this.parser.encodePacket);\n    this._encodeEioPayloadAsync = toAsync<string>(this.parser.encodePayload);\n  }\n\n  public override supportsFraming = (): boolean => false;\n\n  public override name = (): string => WEBPUBSUB_TRANSPORT_NAME;\n\n  /**\n   * sends an array of `Packet` to the client.\n   * @param packets - An array of `Packet` to send\n   */\n  public override async send(packets: EioPacket[]): Promise<void> {\n    debug(\n      `send packets, packets.length = ${packets.length}, packets = ${JSON.stringify(packets)},\\\n_buffer.length=${this._buffer.length}, _buffer=${JSON.stringify(this._buffer)}`\n    );\n    this.writable = false;\n\n    this._buffer.push(...packets);\n    packets = [];\n\n    if (this._buffer.length > 0 && !this._opened) {\n      const firstPacket = this._buffer.shift();\n\n      if (firstPacket.type === \"open\") {\n        const payload = await this._encodeEioPacketAsync(firstPacket, false);\n        debug(`first packet is 'open' packet, payload = ${payload}`);\n        this.clientConnectionContext.onAcceptEioConnection(payload.substring(1));\n        this._opened = true;\n      } else {\n        const errorMessage = `First packet must be a valid packet whose type is 'open', got packet = ${firstPacket}.`;\n        debug(errorMessage);\n        this.clientConnectionContext.onRefuseEioConnection(errorMessage);\n      }\n    }\n\n    while (this._buffer.length > 0) {\n      let sentNumber = 0;\n      try {\n        sentNumber = this._getPacketNumberForNextSend(this._buffer);\n      } catch (error) {\n        debug(`send, internal error, inside _getPacketNumberForNextSend, error = ${error.message},\\\n_buffer=${JSON.stringify(this._buffer)}`);\n        sentNumber = this._buffer.length;\n      }\n      if (sentNumber <= 0) break;\n      const payloads = await this._encodeEioPayloadAsync(this._buffer.splice(0, sentNumber));\n      await this._webPubSubSend(payloads);\n    }\n\n    this.writable = true;\n    // Transport's event `drain` is binded to `flush` method in `Socket` class by its father socket.\n    debug(`send, emit drain`);\n    this.emit(\"drain\");\n\n    debug(`send, finish, _buffer.length=${this._buffer.length}, _buffer=${JSON.stringify(this._buffer)}`);\n  }\n\n  public override doClose(fn?: () => void): void {\n    debug(\"close\");\n    this.send([{ type: \"close\" }]);\n    if (fn) {\n      fn();\n    }\n  }\n\n  protected override onClose(): void {\n    debug(\"onClose\");\n    super.onClose();\n  }\n\n  /**\n   * Send `data` to client via AWPS asynchronously.\n   * @param data - The data to be sent.\n   * @param autoRetry - If true, wait for a certain time and retry sending when the first response status is 429.\n   */\n  private async _webPubSubSend(data: string, autoRetry = false): Promise<void> {\n    debug(`webPubSubSend ${data}`);\n    try {\n      await this.clientConnectionContext.send(data);\n    } catch (error) {\n      debug(error);\n      if (autoRetry && error.response && error.response.status === 429) {\n        const retryAfterSeconds = error.response.headers.get(\"retry-after\");\n        await new Promise((resolve) => setTimeout(resolve, retryAfterSeconds * 1000));\n        await this.clientConnectionContext.send(data);\n      } else {\n        throw error;\n      }\n    }\n    debug(`webPubSubSend, finish`);\n  }\n\n  private _isMessageWithBinary(packet: EioPacket): boolean {\n    return packet.data instanceof ArrayBuffer || ArrayBuffer.isView(packet.data);\n  }\n\n  private _isTypeWithBinary(packet: PartialSioPacket): boolean {\n    return packet.type === SioPacketType.BINARY_EVENT || packet.type === SioPacketType.BINARY_ACK;\n  }\n\n  /**\n   * For SIO mode:\n   *  returns the largest `n` satisfying `packets[0 .. n - 1]` doesn't contain any incomplete binary-related EIO packet sequence.\n   *  A complete binary-related EIO packet sequence = [BINARY_EVENT/BINARY_ACK SIO payload, ...(all its binary attachments)]\n   * For EIO mode:\n   *  The number of binary attachments cannot be inferred. This method returns `packets.length` directly.\n   * @param packets - EIO packets\n   * @returns the number of packets that can be sent in the next REST API call\n   */\n  private _getPacketNumberForNextSend(packets: EioPacket[]): number {\n    if (!this._sioMode) return packets.length;\n\n    /**\n     * Binary Packet = an EIO packet whose data is BINARY_EVENT or BINARY_ACK SIO packet.\n     * Binary Attachment Packet = an EIO packet whose data is binary attachment of a binary packet.\n     */\n    let attachmentCount = 0, // the number of binary attachment packets found for the latest binary packet.\n      expectedAttachments = 0, // the expected number of binary attachment packets for the latest binary packet.\n      lastBinaryMessagePacketIdx = -1, // the index of the latest binary packet.\n      lastSentPacketIdx = -1, // the largest index of EIO packet that can be sent in the next REST API call\n      shouldBeAttachment = false; // whether the current packet should be a binary attachment packet\n\n    for (let i = 0; i < packets.length; i++) {\n      const eioPacket = packets[i];\n\n      // Condition 0: a pure EIO packet without data related to SIO packet.\n      if (eioPacket.type !== \"message\") {\n        lastSentPacketIdx++;\n        continue;\n      }\n\n      // Condition 1: A binary attachment packet\n      if (this._isMessageWithBinary(eioPacket)) {\n        if (!shouldBeAttachment)\n          throw new Error(\n            `Expect a packet whose data is binary attachment but not found, packets[${i}] = ${eioPacket}`\n          );\n\n        attachmentCount++;\n        if (attachmentCount === expectedAttachments) {\n          if (lastBinaryMessagePacketIdx < 0 || lastBinaryMessagePacketIdx >= i)\n            throw new Error(\n              `Invalid lastBinaryMessagePacketIdx = ${lastBinaryMessagePacketIdx}, packets[${i}] = ${eioPacket}`\n            );\n          attachmentCount = 0;\n          shouldBeAttachment = false;\n          lastSentPacketIdx = i;\n        } else {\n          shouldBeAttachment = true;\n        }\n        continue;\n      }\n\n      const sioPacket: PartialSioPacket = decodeStringPartial(eioPacket.data);\n\n      // Condition 2: A binary packet\n      if (this._isTypeWithBinary(sioPacket)) {\n        if (shouldBeAttachment)\n          throw new Error(\n            `Expect a packet with binary content, but got a regular packet, packets[${i}] = ${eioPacket}`\n          );\n        if (attachmentCount !== 0)\n          throw new Error(`Exepect attachmentCount = 0 but got ${attachmentCount}, packets[${i}] = ${eioPacket}`);\n\n        attachmentCount = 0;\n        expectedAttachments = sioPacket.attachments;\n        lastBinaryMessagePacketIdx = i;\n        shouldBeAttachment = true;\n        continue;\n      }\n\n      // Condition 3: A EIO packet whose data is related to SIO packet. But it is neither a binary packet nor a binary attachment packet\n      if (shouldBeAttachment) {\n        throw new Error(`Expect a packet whose data is binary attachment but not found, packets[${i}] = ${eioPacket}`);\n      }\n      shouldBeAttachment = false;\n      lastSentPacketIdx++;\n    }\n    return lastSentPacketIdx + 1;\n  }\n}\n"]}