// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { debugModule, getSioMiddlewareFromExpress, writeResponse, } from "../common/utils";
import { WebPubSubEioServer } from "../EIO";
import { WebPubSubAdapterProxy } from "./components/web-pubsub-adapter";
import { DEFAULT_SIO_PATH, FORBIDDEN_REQUEST_MESSAGE, WEB_PUBSUB_OPTIONS_PROPERY_NAME } from "./components/constants";
import { restoreClaims } from "./components/negotiate";
const debug = debugModule("wps-sio-ext:SIO:index");
debug("load");
export async function useAzureSocketIOChain(webPubSubOptions) {
    debug(`useAzureSocketIOChain, webPubSubOptions: ${JSON.stringify(webPubSubOptions)}`);
    const engine = new WebPubSubEioServer(this.engine.opts, webPubSubOptions);
    const httpServer = this["httpServer"];
    engine.attach(httpServer, this["opts"]);
    // Add negotiate handler
    debug("add negotiate handler");
    const path = this._opts.path || DEFAULT_SIO_PATH;
    // current listeners = EIO handleRequest listeners (e.g. /socket.io) + other listeners from user
    const listeners = httpServer.listeners("request").slice(0);
    httpServer.removeAllListeners("request");
    this[WEB_PUBSUB_OPTIONS_PROPERY_NAME] = webPubSubOptions;
    httpServer.on("request", (req, res) => {
        // Requests routing to EIO `handleRequest` listener should be forbidden. Other listeners should be handled as normal.
        for (let i = 0; i < listeners.length; i++) {
            // Follow the same logic as Engine.IO
            // Reference: https://github.com/socketio/engine.io/blob/6.4.2/lib/server.ts#L804
            if (path !== req.url.slice(0, path.length)) {
                listeners[i].call(httpServer, req, res);
            }
            else {
                debug(`Forbidden request whose url ${req.url} starts with ${path}`);
                writeResponse(res, 403, FORBIDDEN_REQUEST_MESSAGE, "text/plain");
            }
        }
    });
    // `attachServe` is a Socket.IO design which attachs static file serving to internal http server.
    // Creating new engine makes previous `attachServe` execution invalid.
    // Reference: https://github.com/socketio/socket.io/blob/4.6.2/lib/index.ts#L518
    debug("serve static file");
    if (this["_serveClient"]) {
        this["attachServe"](httpServer);
    }
    this.bind(engine);
    debug("use webPubSub adatper");
    const adapterProxy = new WebPubSubAdapterProxy(this.engine.webPubSubConnectionManager.service);
    this.adapter(adapterProxy);
    this.use(getSioMiddlewareFromExpress(restoreClaims()));
    // If using tunnel, wait until connected. `engine.setup` does no nothing when using REST API.
    await engine.setup();
    return this;
}
/**
 * This method returns a Socket.IO server using Web PubSub for Socket.IO.
 *
 * @param io - the Socket.IO server instance
 * @param azureSocketIOOptions - the options of Web PubSub for Socket.IO
 * @returns a Socket.IO server instance using Web PubSub for Socket.IO
 *
 * @public
 */
export async function useAzureSocketIO(io, azureSocketIOOptions) {
    debug(`useAzureSocketIO, azureSocketIOOptions: ${JSON.stringify(azureSocketIOOptions)}`);
    return useAzureSocketIOChain.call(io, azureSocketIOOptions);
}
export { WebPubSubAdapterProxy };
//# sourceMappingURL=index.js.map