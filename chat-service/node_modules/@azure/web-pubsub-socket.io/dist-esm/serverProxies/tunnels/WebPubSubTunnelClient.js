"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebPubSubTunnelClient = void 0;
const web_pubsub_client_1 = require("@azure/web-pubsub-client");
const TunnelMessageProtocol_1 = require("./TunnelMessageProtocol");
const messages_1 = require("./messages");
const core_auth_1 = require("@azure/core-auth");
const logger_1 = require("../logger");
const events_1 = __importDefault(require("events"));
const utils_1 = require("../utils");
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
class WebPubSubTunnelClient {
    userId;
    target;
    _emitter = new events_1.default();
    _client;
    _startedCts = new utils_1.PromiseCompletionSource();
    id = utils_1.Guid.newGuid();
    currentConnectionId;
    stopped = false;
    messageQueue = [];
    constructor(url, credential, userId, target) {
        this.userId = userId;
        this.target = target;
        const options = {
            protocol: new TunnelServerProtocol(),
            autoReconnect: true,
        };
        const client = (this._client = new web_pubsub_client_1.WebPubSubClient({
            getClientAccessUrl: () => {
                return getAccessTokenUrl(url.endpoint, credential, url.reverseProxyEndpoint, userId);
            },
        }, options));
        client.on("connected", (connected) => {
            this.currentConnectionId = connected.connectionId;
            this._startedCts.resolve(connected.connectionId);
        });
        client.on("disconnected", () => {
            this.currentConnectionId = undefined;
        });
        client.on("stopped", () => {
            this.stopped = true;
            this._emitter.emit("stop");
        });
        client.on("server-message", (message) => {
            const bytes = message.message.data;
            let messageBytes;
            if (bytes instanceof ArrayBuffer) {
                messageBytes = new Uint8Array(bytes);
            }
            else if (bytes instanceof Uint8Array) {
                messageBytes = bytes;
            }
            else {
                logger_1.logger.error("Received non-arraybuffer message from server.");
                return;
            }
            var parsed = TunnelMessageProtocol_1.TunnelMessageProtocol.instance.parseMessage(new Uint8Array(bytes));
            if (parsed) {
                this.messageQueue.push(parsed);
                // use messageQueue instead of pass in through emit to gurantee message handle order
                this._emitter.emit("message");
            }
            else {
                logger_1.logger.error("Received invalid message from server.");
            }
        });
    }
    getPrintableIdentifier() {
        return `[${this.id}]${this.currentConnectionId ?? ""}`;
    }
    on(event, listener) {
        this._emitter.on(event, listener);
    }
    off(event, listener) {
        this._emitter.removeListener(event, listener);
    }
    async startAsync(abortSignal) {
        await this._client.start({ abortSignal: abortSignal });
        return await this._startedCts.promise;
    }
    stop() {
        this.stopped = true;
        this._client.stop();
    }
    async sendAsync(message, abortSignal) {
        await this._client.sendEvent(message.Type.toString(), TunnelMessageProtocol_1.TunnelMessageProtocol.instance.getBytes(message), "binary", { fireAndForget: true, abortSignal: abortSignal });
    }
}
exports.WebPubSubTunnelClient = WebPubSubTunnelClient;
class TunnelServerProtocol {
    name = "";
    isReliableSubProtocol = false;
    _protocol = TunnelMessageProtocol_1.TunnelMessageProtocol.instance;
    parseMessages(input) {
        if (typeof input === "string") {
            throw new Error("Expecting ArrayBuffer or Buffer.");
        }
        const buffer = input instanceof Uint8Array ? input : new Uint8Array(input);
        const tunnel = this._protocol.parseMessage(buffer);
        if (!tunnel) {
            throw new Error("Expecting tunnel message");
        }
        if (tunnel.Type == messages_1.TunnelMessageType.ConnectionConnected) {
            const connected = tunnel;
            return {
                connectionId: connected.ConnectionId,
                kind: "connected",
                userId: connected.UserId ?? "",
                reconnectionToken: connected.ReconnectionToken ?? "",
            };
        }
        return {
            kind: "serverData",
            dataType: "binary",
            data: buffer,
        };
    }
    writeMessage(message) {
        // Implement the logic to write the message to a string or ArrayBuffer
        // and return it
        if (message.kind === "sendEvent") {
            if (message.data instanceof ArrayBuffer) {
                return message.data;
            }
            else if (message.data instanceof Uint8Array) {
                return message.data.buffer;
            }
            else {
                throw new Error("Expecting ArrayBuffer or Buffer.");
            }
        }
        throw new Error("Expecting sendEvent.");
    }
}
async function getAccessTokenUrl(endpoint, credential, reverseProxyEndpoint, userId) {
    const url = endpoint.toString();
    let tokenString;
    if (!(0, core_auth_1.isTokenCredential)(credential)) {
        tokenString = signJwtToken(credential, url, userId);
    }
    else {
        tokenString = (await credential.getToken("https://webpubsub.azure.com/.default")).token;
    }
    return `${reverseProxyEndpoint?.toString() ?? url}&access_token=${encodeURIComponent(tokenString)}`;
}
function signJwtToken(credential, audience, userId) {
    return jsonwebtoken_1.default.sign({}, credential.key, {
        subject: userId,
        audience: audience,
        expiresIn: "1h",
        algorithm: "HS256",
    });
}
