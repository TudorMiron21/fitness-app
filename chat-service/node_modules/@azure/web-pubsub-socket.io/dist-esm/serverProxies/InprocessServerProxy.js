"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InprocessServerProxy = void 0;
const TunnelConnection_1 = require("./tunnels/TunnelConnection");
const http = __importStar(require("http"));
const net_1 = require("net");
const logger_1 = require("./logger");
const utils_1 = require("./utils");
const logger = (0, logger_1.createLogger)("InprocessServerProxy");
const apiVersion = "2023-07-01";
const httpMethodPost = "POST";
const httpMethodDelete = "DELETE";
const consistentKeyForSendToAll = "keyForSendToAll";
class InprocessServerProxy {
    _tunnel;
    _hub;
    _encoder = new TextEncoder();
    static fromConnectionString(connectionString, hub, handler, reverseProxyEndpoint) {
        const { credential, endpoint } = (0, utils_1.parseConnectionString)(connectionString);
        return new InprocessServerProxy(endpoint, credential, hub, handler, reverseProxyEndpoint);
    }
    constructor(endpoint, credential, hub, handler, reverseProxyEndpoint) {
        this._tunnel = new TunnelConnection_1.TunnelConnection(endpoint, credential, hub, this._getRequestHandler(handler), reverseProxyEndpoint);
        this._hub = hub;
    }
    group(groupName) {
        return {
            removeConnection: (connectionId) => {
                return this._removeConnectionFromGroup(connectionId, groupName);
            },
            sendToAll: (message, options) => {
                return this._sendToGroup(groupName, message, options);
            }
        };
    }
    async sendToConnection(connectionId, message, options) {
        let request = {
            method: httpMethodPost,
            url: this._getUrl(`/api/hubs/${this._hub}/connections/${connectionId}/:send`),
            content: this._encoder.encode(message),
            contentType: "text/plain",
        };
        // Order concern here: web-pubsub-transport.send() has already guarantee the order by a queue
        let response = await this._tunnel.invokeAsync(request);
        if (response.statusCode !== 202) {
            throw new Error(`sendToConnection got unexpected status code ${response.statusCode}`);
        }
    }
    async sendToAll(message, options) {
        let query = {};
        if (options?.filter) {
            query = { "filter": options.filter };
        }
        let request = {
            method: httpMethodPost,
            url: this._getUrl(`/api/hubs/${this._hub}/:send`, query),
            content: this._encoder.encode(message),
            contentType: "text/plain",
        };
        let response = await this._tunnel.invokeAsync(request, undefined, consistentKeyForSendToAll);
        if (response.statusCode !== 202) {
            throw new Error(`sendToAll got unexpected status code ${response.statusCode}`);
        }
    }
    async removeConnectionsFromGroups(groups, filter) {
        let body = {
            groups: groups,
            filter: filter,
        };
        let request = {
            method: httpMethodPost,
            url: this._getUrl(`/api/hubs/${this._hub}/:removeFromGroups`),
            content: this._encoder.encode(JSON.stringify(body)),
            contentType: "application/json",
        };
        let response = await this._tunnel.invokeAsync(request);
        if (response.statusCode !== 200) {
            throw new Error(`removeConnectionsFromGroups got unexpected status code ${response.statusCode}`);
        }
    }
    async addConnectionsToGroups(groups, filter) {
        let body = {
            groups: groups,
            filter: filter,
        };
        let request = {
            method: httpMethodPost,
            url: this._getUrl(`/api/hubs/${this._hub}/:addToGroups`),
            content: this._encoder.encode(JSON.stringify(body)),
            contentType: "application/json",
        };
        let response = await this._tunnel.invokeAsync(request);
        if (response.statusCode !== 200) {
            throw new Error(`addConnectionsToGroups got unexpected status code ${response.statusCode}`);
        }
    }
    async _removeConnectionFromGroup(connectionId, groupName) {
        let request = {
            method: httpMethodDelete,
            url: this._getUrl(`/api/hubs/${this._hub}/groups/${groupName}/connections/${connectionId}`),
        };
        let response = await this._tunnel.invokeAsync(request, undefined, groupName);
        if (response.statusCode !== 200 && response.statusCode !== 204) {
            throw new Error(`removeConnectionFromGroup got unexpected status code ${response.statusCode}`);
        }
    }
    async _sendToGroup(groupName, message, options) {
        let query = {};
        if (options?.filter) {
            query = { "filter": options.filter };
        }
        let request = {
            method: httpMethodPost,
            url: this._getUrl(`/api/hubs/${this._hub}/groups/${groupName}/:send`, query),
            content: this._encoder.encode(message),
            contentType: "text/plain",
        };
        let response = await this._tunnel.invokeAsync(request, undefined, groupName);
        if (response.statusCode !== 202) {
            throw new Error(`sendToGroup got unexpected status code ${response.statusCode}`);
        }
    }
    async invoke(message, body, options) {
        let query = {};
        if (options?.filter) {
            query = { "filter": options.filter };
        }
        let request = {
            method: httpMethodPost,
            url: this._getUrl(`/api/hubs/${this._hub}/:invoke`, query),
            content: this._encoder.encode(message),
            contentType: "text/plain",
        };
        let response = await this._tunnel.invokeAsync(request, undefined, consistentKeyForSendToAll);
        if (response.statusCode !== 200) {
            throw new Error(`invoke got unexpected status code ${response.statusCode}`);
        }
        let readBody = async () => {
            for await (const chunk of response.body) {
                body(chunk, false);
            }
            body(undefined, true);
        };
        setTimeout(() => readBody(), 0);
    }
    runAsync(abortSignal) {
        return this._tunnel.runAsync(() => true, abortSignal); // keep it retry forever now to be consistent with current logic
    }
    stop() {
        this._tunnel.stop();
    }
    use(handler) {
        this._tunnel.requestHandler = this._getRequestHandler(handler);
    }
    _getRequestHandler(handler) {
        if (!handler) {
            return undefined;
        }
        return function (request, abortSignal) {
            const req = buildRequest(request);
            const res = new ContentInterpreteResponse(req);
            var url = new URL(request.Url);
            req.baseUrl = "";
            req.path = url.pathname;
            const responseReader = readResponse(res, abortSignal);
            handler(req, res, (err) => {
                // end the response
                err = "Not correctly handled. " + err ?? "";
                logger.error(err);
                res.statusCode = 500;
                res.end(err);
            });
            // make sure request content is set after request emit is registered in handler
            if (request.Content) {
                req.emit("data", request.Content);
            }
            req.emit("end");
            return responseReader;
        };
    }
    _getUrl(path, query) {
        const baseUrl = "https://host";
        const url = new URL(baseUrl);
        url.pathname = path;
        url.searchParams.append("api-version", apiVersion);
        if (query) {
            for (const key in query) {
                url.searchParams.append(key, query[key]);
            }
        }
        return url.toString();
    }
}
exports.InprocessServerProxy = InprocessServerProxy;
function buildRequest(tunnelRequest) {
    const req = new http.IncomingMessage(new net_1.Socket());
    if (tunnelRequest.Headers) {
        for (const header in tunnelRequest.Headers) {
            req.headers[header.toLowerCase()] = tunnelRequest.Headers[header];
        }
    }
    req.url = tunnelRequest.Url;
    req.method = tunnelRequest.HttpMethod;
    return req;
}
/* Highly depends on current web-pubsub-express's implementation that only end is called when sending body back */
class ContentInterpreteResponse extends http.ServerResponse {
    constructor(req) {
        super(req);
    }
    end(chunkOrCb, encodingOrCb, cb) {
        if (chunkOrCb === undefined) {
            super.end();
        }
        else if (typeof chunkOrCb === "function") {
            super.end(chunkOrCb);
        }
        else {
            const chunk = chunkOrCb;
            if (chunk === undefined) {
                throw new Error("Not supported data type!");
            }
            if (typeof chunk === "string") {
                // only supports utf8
                const bytes = new TextEncoder().encode(chunk);
                this.emit("data", bytes);
            }
            else if (ArrayBuffer.isView(chunk)) {
                this.emit("data", new Uint8Array(chunk));
            }
            else {
                this.emit("data", chunk);
            }
            if (encodingOrCb === undefined) {
                super.end(chunk);
            }
            else {
                if (typeof encodingOrCb === "function") {
                    super.end(chunk, encodingOrCb);
                }
                else {
                    super.end(chunk, encodingOrCb, cb);
                }
            }
        }
        this.emit("end");
        return this;
    }
    id = ContentInterpreteResponse.name;
}
function convertHeaders(headers) {
    const result = {};
    for (const key in headers) {
        const header = headers[key];
        if (header !== undefined) {
            if (typeof header === "string") {
                result[key] = [header];
            }
            else if (Array.isArray(header)) {
                result[key] = header;
            }
        }
    }
    return result;
}
function readResponse(res, abortSignal) {
    return new Promise((resolve, reject) => {
        const chunks = [];
        abortSignal?.addEventListener("abort", () => reject("cancelled"));
        res.on("data", (chunk) => {
            chunks.push(chunk);
        });
        res.on("end", () => {
            resolve({
                StatusCode: res.statusCode ?? 0,
                Headers: convertHeaders(res.getHeaders()),
                Content: new Uint8Array(Buffer.concat(chunks)),
            });
        });
        res.on("error", (err) => {
            reject(err);
        });
    });
}
