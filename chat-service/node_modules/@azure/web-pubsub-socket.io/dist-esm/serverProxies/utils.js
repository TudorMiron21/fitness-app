"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AsyncIterator = exports.parseConnectionString = exports.Guid = exports.PromiseCompletionSource = exports.AckEntity = void 0;
const core_auth_1 = require("@azure/core-auth");
const url_1 = require("url");
class AckEntity {
    _reader;
    constructor(ackId, reader, abortSignal) {
        this._reader = reader;
        this.ackId = ackId;
        abortSignal?.addEventListener("abort", () => {
            // TODO: clean it from map
            this.write(undefined, "aborted", true);
        });
    }
    ackId;
    write(value, error, done) {
        setTimeout(() => {
            this._reader(value, error, done);
        }, 0);
    }
}
exports.AckEntity = AckEntity;
class PromiseCompletionSource {
    _resolve;
    _reject;
    promise = new Promise((resolve, reject) => {
        this._resolve = resolve;
        this._reject = reject;
    });
    resolve(value) {
        this._resolve(value);
    }
    reject(reason) {
        this._reject(reason);
    }
}
exports.PromiseCompletionSource = PromiseCompletionSource;
class Guid {
    static newGuid() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
            const r = (Math.random() * 16) | 0;
            const v = c === "x" ? r : (r & 0x3) | 0x8;
            return v.toString(16);
        });
    }
}
exports.Guid = Guid;
function parseConnectionString(conn) {
    const parsed = {};
    conn.split(";").forEach((i) => {
        const assignmentPos = i.indexOf("=");
        if (assignmentPos === -1)
            return;
        const key = i.substring(0, assignmentPos).toLowerCase();
        const value = i.substring(assignmentPos + 1);
        parsed[key] = value;
    });
    let endpointPart = parsed["endpoint"];
    if (!endpointPart)
        throw new TypeError("connection string missing endpoint");
    if (!endpointPart.startsWith("http")) {
        endpointPart = `https://${endpointPart}`;
    }
    const key = parsed["accesskey"];
    if (!key)
        throw new TypeError("connection string missing access key");
    const credential = new core_auth_1.AzureKeyCredential(key);
    const port = parsed["port"];
    const url = new url_1.URL(endpointPart);
    url.port = port;
    const endpoint = url.toString();
    url.port = "";
    return { credential, endpoint };
}
exports.parseConnectionString = parseConnectionString;
class AsyncIterator {
    items = [];
    isClosed = false;
    resolveCurrent = null;
    errorToThrow = null;
    add(item) {
        if (!this.isClosed) {
            this.items.push(item);
            if (this.resolveCurrent) {
                this.resolveCurrent();
                this.resolveCurrent = null;
            }
        }
        else {
            throw new Error('Iterator has been closed. No more items can be added.');
        }
    }
    async next() {
        if (this.errorToThrow) {
            throw this.errorToThrow;
        }
        if (this.items.length > 0) {
            let item = this.items.shift();
            return { value: item, done: false };
        }
        else if (this.isClosed) {
            return { done: true, value: undefined };
        }
        else {
            await new Promise((resolve) => {
                this.resolveCurrent = resolve;
            });
            if (this.errorToThrow) {
                throw this.errorToThrow;
            }
            if (this.items.length > 0) {
                let item = this.items.shift();
                return { value: item, done: false };
            }
            else {
                return { done: true, value: undefined };
            }
        }
    }
    error(err) {
        this.errorToThrow = err;
        if (this.resolveCurrent) {
            this.resolveCurrent();
            this.resolveCurrent = null;
        }
    }
    close() {
        this.isClosed = true;
        if (this.resolveCurrent) {
            this.resolveCurrent();
            this.resolveCurrent = null;
        }
    }
    [Symbol.asyncIterator]() {
        return this;
    }
}
exports.AsyncIterator = AsyncIterator;
async function readToEnd(iterator) {
    const chunks = [];
    for await (const chunk of iterator) {
        chunks.push(chunk);
    }
    return concatUint8Arrays(...chunks);
}
function concatUint8Arrays(...arrays) {
    const totalLength = arrays.reduce((acc, array) => acc + array.length, 0);
    const resultArray = new Uint8Array(totalLength);
    let offset = 0;
    for (const array of arrays) {
        resultArray.set(array, offset);
        offset += array.length;
    }
    return resultArray;
}
