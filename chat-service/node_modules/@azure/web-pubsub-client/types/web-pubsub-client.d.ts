/// <reference types="node" />

import { AbortSignalLike } from '@azure/abort-controller';

/**
 * The ack message
 */
export declare interface AckMessage extends WebPubSubMessageBase {
    /**
     * Message type
     */
    readonly kind: "ack";
    /**
     * The correspending id
     */
    ackId: number;
    /**
     * Is operation success or not
     */
    success: boolean;
    /**
     * The error detail. Only available when success is false
     */
    error?: AckMessageError;
}

/**
 * Error detail in AckMessage
 */
export declare interface AckMessageError {
    /**
     * Error name
     */
    name: string;
    /**
     * Details error message
     */
    message: string;
}

/**
 * Connected message
 */
export declare interface ConnectedMessage extends WebPubSubMessageBase {
    /**
     * Message type
     */
    readonly kind: "connected";
    /**
     * The connection id
     */
    connectionId: string;
    /**
     * The user id of the client connection
     */
    userId: string;
    /**
     * The reconnection token. Only available in reliable protocols.
     */
    reconnectionToken: string;
}

/**
 * Disconnected message
 */
export declare interface DisconnectedMessage extends WebPubSubMessageBase {
    /**
     * Message type
     */
    readonly kind: "disconnected";
    /**
     * Reason of disconnection.
     */
    message: string;
}

/**
 * Types for downstream messages
 */
export declare type DownstreamMessageType = 
/**
* Type for AckMessage
*/
"ack"
/**
* Type for ConnectedMessage
*/
| "connected"
/**
* Type for DisconnectedMessage
*/
| "disconnected"
/**
* Type for GroupDataMessage
*/
| "groupData"
/**
* Type for ServerDataMessage
*/
| "serverData";

/**
 * The start options
 */
export declare interface GetClientAccessUrlOptions {
    /**
     * The abort signal
     */
    abortSignal?: AbortSignalLike;
}

/**
 * Group data message
 */
export declare interface GroupDataMessage extends WebPubSubMessageBase {
    /**
     * Message type
     */
    readonly kind: "groupData";
    /**
     * The data type
     */
    dataType: WebPubSubDataType;
    /**
     * The data
     */
    data: JSONTypes | ArrayBuffer;
    /**
     * The sequence id of the data. Only available in reliable protocols
     */
    sequenceId?: number;
    /**
     * The name of group that the message come from.
     */
    group: string;
    /**
     * The user id of the sender
     */
    fromUserId: string;
}

/**
 * Join group message
 */
export declare interface JoinGroupMessage extends WebPubSubMessageBase {
    /**
     * Message type
     */
    readonly kind: "joinGroup";
    /**
     * The group to join
     */
    group: string;
    /**
     * Optional ack id. If specified, an AckMessage with success or not will be returned with the same ackId
     */
    ackId?: number;
}

/**
 * Join group operation options
 */
export declare interface JoinGroupOptions {
    /**
     * The optional ackId. If not specified, client will generate one.
     */
    ackId?: number;
    /**
     * The abort signal
     */
    abortSignal?: AbortSignalLike;
}

/**
 * Types which can be serialized and sent as JSON.
 */
export declare type JSONTypes = string | number | boolean | object;

/**
 * Leave group message
 */
export declare interface LeaveGroupMessage extends WebPubSubMessageBase {
    /**
     * Message type
     */
    readonly kind: "leaveGroup";
    /**
     * The group to leave
     */
    group: string;
    /**
     * Optional ack id. If specified, an AckMessage with success or not will be returned with the same ackId
     */
    ackId?: number;
}

/**
 * Leave group operation options
 */
export declare interface LeaveGroupOptions {
    /**
     * The optional ackId. If not specified, client will generate one.
     */
    ackId?: number;
    /**
     * The abort signal
     */
    abortSignal?: AbortSignalLike;
}

/**
 * Parameter of OnConnected callback
 */
export declare interface OnConnectedArgs {
    /**
     * The connection id
     */
    connectionId: string;
    /**
     * The user id of the client connection
     */
    userId: string;
}

/**
 * Parameter of OnDisconnected callback
 */
export declare interface OnDisconnectedArgs {
    /**
     * The connection id
     */
    connectionId?: string;
    /**
     * The disconnected message
     */
    message?: DisconnectedMessage;
}

/**
 * Parameter of OnGroupDataMessage callback
 */
export declare interface OnGroupDataMessageArgs {
    /**
     * The group data message
     */
    message: GroupDataMessage;
}

/**
 * Parameter of RejoinGroupFailed callback
 */
export declare interface OnRejoinGroupFailedArgs {
    /**
     * The group name
     */
    group: string;
    /**
     * The failure error
     */
    error: Error;
}

/**
 * Parameter of OnDataMessage callback
 */
export declare interface OnServerDataMessageArgs {
    /**
     * The data message
     */
    message: ServerDataMessage;
}

/**
 * Parameter of OnStopped callback
 */
export declare interface OnStoppedArgs {
}

/**
 * Describes the Retry Mode type
 */
export declare type RetryMode = "Exponential" | "Fixed";

/**
 * Send custom event message
 */
export declare interface SendEventMessage extends WebPubSubMessageBase {
    /**
     * Message type
     */
    readonly kind: "sendEvent";
    /**
     * Optional ack id. If specified, an AckMessage with success or not will be returned with the same ackId
     */
    ackId?: number;
    /**
     * The data type
     */
    dataType: WebPubSubDataType;
    /**
     * The data
     */
    data: JSONTypes | ArrayBuffer;
    /**
     * The event name
     */
    event: string;
}

/**
 * Send event operation options
 */
export declare interface SendEventOptions {
    /**
     * If true, the message won't contains ackId. No AckMessage will be returned from the service.
     */
    fireAndForget?: boolean;
    /**
     * The optional ackId. If not specified, client will generate one.
     */
    ackId?: number;
    /**
     * The abort signal
     */
    abortSignal?: AbortSignalLike;
}

/**
 * Error when sending message failed
 */
export declare class SendMessageError extends Error {
    /**
     * Error name
     */
    name: string;
    /**
     * The ack id of the message
     */
    ackId?: number;
    /**
     * The error details from the service
     */
    errorDetail?: AckMessageError;
    /**
     * Initialize a SendMessageError
     * @param message - The error message
     * @param ackMessage - The ack message
     */
    constructor(message: string, options: SendMessageErrorOptions);
}

export declare interface SendMessageErrorOptions {
    /**
     * The ack id of the message
     */
    ackId?: number;
    /**
     * The error details from the service
     */
    errorDetail?: AckMessageError;
}

/**
 * Send to group message
 */
export declare interface SendToGroupMessage extends WebPubSubMessageBase {
    /**
     * Message type
     */
    readonly kind: "sendToGroup";
    /**
     * The group to send
     */
    group: string;
    /**
     * Optional ack id. If specified, an AckMessage with success or not will be returned with the same ackId
     */
    ackId?: number;
    /**
     * The data type
     */
    dataType: WebPubSubDataType;
    /**
     * The data
     */
    data: JSONTypes | ArrayBuffer;
    /**
     * Whether the message needs to echo to sender
     */
    noEcho: boolean;
}

/**
 * Send to group operation options
 */
export declare interface SendToGroupOptions {
    /**
     * Whether the message needs to echo to sender
     */
    noEcho?: boolean;
    /**
     * If true, the message won't contains ackId. No AckMessage will be returned from the service.
     */
    fireAndForget?: boolean;
    /**
     * The optional ackId. If not specified, client will generate one.
     */
    ackId?: number;
    /**
     * The abort signal
     */
    abortSignal?: AbortSignalLike;
}

/**
 * Sequence ack message
 */
export declare interface SequenceAckMessage extends WebPubSubMessageBase {
    /**
     * Message type
     */
    readonly kind: "sequenceAck";
    /**
     * The sequence id
     */
    sequenceId: number;
}

/**
 * Server data message
 */
export declare interface ServerDataMessage extends WebPubSubMessageBase {
    /**
     * Message type
     */
    readonly kind: "serverData";
    /**
     * The data type
     */
    dataType: WebPubSubDataType;
    /**
     * The data
     */
    data: JSONTypes | ArrayBuffer;
    /**
     * The sequence id of the data. Only available in reliable protocols
     */
    sequenceId?: number;
}

/**
 * The start options
 */
export declare interface StartOptions {
    /**
     * The abort signal
     */
    abortSignal?: AbortSignalLike;
}

/**
 * Types for upstream messages
 */
export declare type UpstreamMessageType = 
/**
* Type for JoinGroupMessage
*/
"joinGroup"
/**
* Type for LeaveGroupMessage
*/
| "leaveGroup"
/**
* Type for SendToGroupMessage
*/
| "sendToGroup"
/**
* Type for SendEventMessage
*/
| "sendEvent"
/**
* Type for SequenceAckMessage
*/
| "sequenceAck";

/**
 * The WebPubSub client
 */
export declare class WebPubSubClient {
    private readonly _protocol;
    private readonly _credential;
    private readonly _options;
    private readonly _groupMap;
    private readonly _ackMap;
    private readonly _sequenceId;
    private readonly _messageRetryPolicy;
    private readonly _reconnectRetryPolicy;
    private readonly _quickSequenceAckDiff;
    private readonly _activeTimeoutInMs;
    private readonly _emitter;
    private _state;
    private _isStopping;
    private _ackId;
    private _activeKeepaliveTask;
    private _wsClient?;
    private _uri?;
    private _lastCloseEvent?;
    private _lastDisconnectedMessage?;
    private _connectionId?;
    private _reconnectionToken?;
    private _isInitialConnected;
    private _sequenceAckTask?;
    private nextAckId;
    /**
     * Create an instance of WebPubSubClient
     * @param clientAccessUrl - The uri to connect
     * @param options - The client options
     */
    constructor(clientAccessUrl: string, options?: WebPubSubClientOptions);
    /**
     * Create an instance of WebPubSubClient
     * @param credential - The credential to use when connecting
     * @param options - The client options
     */
    constructor(credential: WebPubSubClientCredential, options?: WebPubSubClientOptions);
    /**
     * Start to start to the service.
     * @param abortSignal - The abort signal
     */
    start(options?: StartOptions): Promise<void>;
    private _startFromRestarting;
    private _startCore;
    /**
     * Stop the client.
     */
    stop(): void;
    /**
     * Add handler for connected event
     * @param event - The event name
     * @param listener - The handler
     */
    on(event: "connected", listener: (e: OnConnectedArgs) => void): void;
    /**
     * Add handler for disconnected event
     * @param event - The event name
     * @param listener - The handler
     */
    on(event: "disconnected", listener: (e: OnDisconnectedArgs) => void): void;
    /**
     * Add handler for stopped event
     * @param event - The event name
     * @param listener - The handler
     */
    on(event: "stopped", listener: (e: OnStoppedArgs) => void): void;
    /**
     * Add handler for server messages
     * @param event - The event name
     * @param listener - The handler
     */
    on(event: "server-message", listener: (e: OnServerDataMessageArgs) => void): void;
    /**
     * Add handler for group messags
     * @param event - The event name
     * @param listener - The handler
     */
    on(event: "group-message", listener: (e: OnGroupDataMessageArgs) => void): void;
    /**
     * Add handler for rejoining group failed
     * @param event - The event name
     * @param listener - The handler
     */
    on(event: "rejoin-group-failed", listener: (e: OnRejoinGroupFailedArgs) => void): void;
    /**
     * Remove handler for connected event
     * @param event - The event name
     * @param listener - The handler
     */
    off(event: "connected", listener: (e: OnConnectedArgs) => void): void;
    /**
     * Remove handler for disconnected event
     * @param event - The event name
     * @param listener - The handler
     */
    off(event: "disconnected", listener: (e: OnDisconnectedArgs) => void): void;
    /**
     * Remove handler for stopped event
     * @param event - The event name
     * @param listener - The handler
     */
    off(event: "stopped", listener: (e: OnStoppedArgs) => void): void;
    /**
     * Remove handler for server message
     * @param event - The event name
     * @param listener - The handler
     */
    off(event: "server-message", listener: (e: OnServerDataMessageArgs) => void): void;
    /**
     * Remove handler for group message
     * @param event - The event name
     * @param listener - The handler
     */
    off(event: "group-message", listener: (e: OnGroupDataMessageArgs) => void): void;
    /**
     * Remove handler for rejoining group failed
     * @param event - The event name
     * @param listener - The handler
     */
    off(event: "rejoin-group-failed", listener: (e: OnRejoinGroupFailedArgs) => void): void;
    private _emitEvent;
    /**
     * Send custom event to server.
     * @param eventName - The event name
     * @param content - The data content
     * @param dataType - The data type
     * @param options - The options
     * @param abortSignal - The abort signal
     */
    sendEvent(eventName: string, content: JSONTypes | ArrayBuffer, dataType: WebPubSubDataType, options?: SendEventOptions): Promise<WebPubSubResult>;
    private _sendEventAttempt;
    /**
     * Join the client to group
     * @param groupName - The group name
     * @param options - The join group options
     */
    joinGroup(groupName: string, options?: JoinGroupOptions): Promise<WebPubSubResult>;
    private _joinGroupAttempt;
    private _joinGroupCore;
    /**
     * Leave the client from group
     * @param groupName - The group name
     * @param ackId - The optional ackId. If not specified, client will generate one.
     * @param abortSignal - The abort signal
     */
    leaveGroup(groupName: string, options?: LeaveGroupOptions): Promise<WebPubSubResult>;
    private _leaveGroupAttempt;
    /**
     * Send message to group.
     * @param groupName - The group name
     * @param content - The data content
     * @param dataType - The data type
     * @param options - The options
     * @param abortSignal - The abort signal
     */
    sendToGroup(groupName: string, content: JSONTypes | ArrayBuffer, dataType: WebPubSubDataType, options?: SendToGroupOptions): Promise<WebPubSubResult>;
    private _sendToGroupAttempt;
    private _getWebSocketClientFactory;
    private _trySendSequenceAck;
    private _connectCore;
    private _handleConnectionCloseAndNoRecovery;
    private _autoReconnect;
    private _handleConnectionStopped;
    private _getActiveKeepaliveTask;
    private _sendMessage;
    private _sendMessageWithAckId;
    private _handleConnectionClose;
    private _safeEmitConnected;
    private _safeEmitDisconnected;
    private _safeEmitGroupMessage;
    private _safeEmitServerMessage;
    private _safeEmitStopped;
    private _safeEmitRejoinGroupFailed;
    private _buildDefaultOptions;
    private _buildMessageRetryOptions;
    private _buildReconnectRetryOptions;
    private _buildRecoveryUri;
    private _getOrAddGroup;
    private _changeState;
    private _operationExecuteWithRetry;
}

/**
 * The WebPubSubClient credential
 */
export declare interface WebPubSubClientCredential {
    /**
     * Gets an `getClientAccessUrl` which is used in connecting to the service
     * @param abortSignal - An implementation of `AbortSignalLike` to cancel the operation.
     */
    getClientAccessUrl: string | ((options?: GetClientAccessUrlOptions) => Promise<string>);
}

/**
 * The client options
 */
export declare interface WebPubSubClientOptions {
    /**
     * The subprotocol
     */
    protocol?: WebPubSubClientProtocol;
    /**
     * Whether to auto reconnect after connection is dropped and not recoverable
     */
    autoReconnect?: boolean;
    /**
     * Whether to enable restoring group after reconnecting
     */
    autoRejoinGroups?: boolean;
    /**
     * The retry options for operations like joining group and sending messages
     */
    messageRetryOptions?: WebPubSubRetryOptions;
    /**
     * The retry options for reconnection. Only available when autoReconnect is true.
     */
    reconnectRetryOptions?: WebPubSubRetryOptions;
}

/**
 * The interface to be implemented for a web pubsub subprotocol
 */
export declare interface WebPubSubClientProtocol {
    /**
     * The name of subprotocol. Name will be used in websocket subprotocol
     */
    readonly name: string;
    /**
     * True if the protocol supports reliable features
     */
    readonly isReliableSubProtocol: boolean;
    /**
     * Creates WebPubSubMessage objects from the specified serialized representation.
     * @param input - The serialized representation
     */
    parseMessages(input: string | ArrayBuffer | Buffer): WebPubSubMessage[] | WebPubSubMessage | null;
    /**
     * Write WebPubSubMessage to string or ArrayBuffer
     * @param message - The message to be written
     */
    writeMessage(message: WebPubSubMessage): string | ArrayBuffer;
}

/**
 * The data type
 */
export declare type WebPubSubDataType = 
/**
* Binary type
*/
"binary"
/**
* Json type
*/
| "json"
/**
* Text type
*/
| "text"
/**
* Protobuf type
*/
| "protobuf";

/**
 * Return the "json.webpubsub.azure.v1" protocol
 */
export declare const WebPubSubJsonProtocol: () => WebPubSubClientProtocol;

/**
 * Return the "json.reliable.webpubsub.azure.v1" protocol
 */
export declare const WebPubSubJsonReliableProtocol: () => WebPubSubClientProtocol;

/**
 * The web pubsub message
 */
export declare type WebPubSubMessage = GroupDataMessage | ServerDataMessage | JoinGroupMessage | LeaveGroupMessage | ConnectedMessage | DisconnectedMessage | SendToGroupMessage | SendEventMessage | SequenceAckMessage | AckMessage;

/**
 * The common of web pubsub message
 */
export declare interface WebPubSubMessageBase {
    kind: DownstreamMessageType | UpstreamMessageType;
}

/**
 * The ack result
 */
export declare interface WebPubSubResult {
    /**
     * The ack message from the service. If the message is fire-and-forget, this will be undefined.
     */
    ackId?: number;
    /**
     * Whether the message is duplicated.
     */
    isDuplicated: boolean;
}

/**
 * The retry options
 */
export declare interface WebPubSubRetryOptions {
    /**
     * Number of times the operation needs to be retried in case
     * of retryable error. Default: 3.
     */
    maxRetries?: number;
    /**
     * Amount of time to wait in milliseconds before making the
     * next attempt. Default: `1000 milliseconds`.
     * When `mode` option is set to `Exponential`,
     * this is used to compute the exponentially increasing delays between retries.
     */
    retryDelayInMs?: number;
    /**
     * Denotes the maximum delay between retries
     * that the retry attempts will be capped at. Applicable only when performing exponential retry.
     */
    maxRetryDelayInMs?: number;
    /**
     * Denotes which retry mode to apply. If undefined, defaults to `Fixed`
     */
    mode?: RetryMode;
}

export { }
