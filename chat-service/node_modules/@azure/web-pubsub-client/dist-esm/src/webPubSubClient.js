// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { AbortController } from "@azure/abort-controller";
import { delay } from "@azure/core-util";
import EventEmitter from "events";
import { SendMessageError } from "./errors";
import { logger } from "./logger";
import { WebPubSubJsonReliableProtocol } from "./protocols";
import { WebSocketClientFactory } from "./websocket/websocketClient";
import { abortablePromise } from "./utils/abortablePromise";
var WebPubSubClientState;
(function (WebPubSubClientState) {
    WebPubSubClientState["Stopped"] = "Stopped";
    WebPubSubClientState["Disconnected"] = "Disconnected";
    WebPubSubClientState["Connecting"] = "Connecting";
    WebPubSubClientState["Connected"] = "Connected";
    WebPubSubClientState["Recovering"] = "Recovering";
})(WebPubSubClientState || (WebPubSubClientState = {}));
/**
 * The WebPubSub client
 */
export class WebPubSubClient {
    nextAckId() {
        this._ackId = this._ackId + 1;
        return this._ackId;
    }
    constructor(credential, options) {
        this._quickSequenceAckDiff = 300;
        this._activeTimeoutInMs = 20000;
        this._emitter = new EventEmitter();
        this._isStopping = false;
        this._isInitialConnected = false;
        if (typeof credential === "string") {
            this._credential = { getClientAccessUrl: credential };
        }
        else {
            this._credential = credential;
        }
        if (options == null) {
            options = {};
        }
        this._buildDefaultOptions(options);
        this._options = options;
        this._messageRetryPolicy = new RetryPolicy(this._options.messageRetryOptions);
        this._reconnectRetryPolicy = new RetryPolicy(this._options.reconnectRetryOptions);
        this._protocol = this._options.protocol;
        this._groupMap = new Map();
        this._ackMap = new Map();
        this._sequenceId = new SequenceId();
        this._state = WebPubSubClientState.Stopped;
        this._ackId = 0;
    }
    /**
     * Start to start to the service.
     * @param abortSignal - The abort signal
     */
    async start(options) {
        if (this._isStopping) {
            throw new Error("Can't start a client during stopping");
        }
        if (this._state !== WebPubSubClientState.Stopped) {
            throw new Error("Client can be only started when it's Stopped");
        }
        let abortSignal;
        if (options) {
            abortSignal = options.abortSignal;
        }
        if (!this._activeKeepaliveTask) {
            this._activeKeepaliveTask = this._getActiveKeepaliveTask();
        }
        try {
            await this._startCore(abortSignal);
        }
        catch (err) {
            // this two sentense should be set together. Consider client.stop() is called during _startCore()
            this._changeState(WebPubSubClientState.Stopped);
            if (this._activeKeepaliveTask) {
                this._activeKeepaliveTask.abort();
                this._activeKeepaliveTask = undefined;
            }
            this._isStopping = false;
            throw err;
        }
    }
    async _startFromRestarting(abortSignal) {
        if (this._state !== WebPubSubClientState.Disconnected) {
            throw new Error("Client can be only restarted when it's Disconnected");
        }
        try {
            logger.verbose("Staring reconnecting.");
            await this._startCore(abortSignal);
        }
        catch (err) {
            this._changeState(WebPubSubClientState.Disconnected);
            throw err;
        }
    }
    async _startCore(abortSignal) {
        this._changeState(WebPubSubClientState.Connecting);
        logger.info("Staring a new connection");
        // Reset before a pure new connection
        this._sequenceId.reset();
        this._isInitialConnected = false;
        this._lastCloseEvent = undefined;
        this._lastDisconnectedMessage = undefined;
        this._connectionId = undefined;
        this._reconnectionToken = undefined;
        this._uri = undefined;
        if (typeof this._credential.getClientAccessUrl === "string") {
            this._uri = this._credential.getClientAccessUrl;
        }
        else {
            this._uri = await this._credential.getClientAccessUrl({
                abortSignal: abortSignal,
            });
        }
        if (typeof this._uri !== "string") {
            throw new Error(`The clientAccessUrl must be a string but currently it's ${typeof this._uri}`);
        }
        await this._connectCore(this._uri);
    }
    /**
     * Stop the client.
     */
    stop() {
        if (this._state === WebPubSubClientState.Stopped || this._isStopping) {
            return;
        }
        // TODO: Maybe we need a better logic for stopping control
        this._isStopping = true;
        if (this._wsClient && this._wsClient.isOpen()) {
            this._wsClient.close();
        }
        else {
            this._isStopping = false;
        }
        if (this._activeKeepaliveTask) {
            this._activeKeepaliveTask.abort();
            this._activeKeepaliveTask = undefined;
        }
    }
    on(event, listener) {
        this._emitter.on(event, listener);
    }
    off(event, listener) {
        this._emitter.removeListener(event, listener);
    }
    _emitEvent(event, args) {
        this._emitter.emit(event, args);
    }
    /**
     * Send custom event to server.
     * @param eventName - The event name
     * @param content - The data content
     * @param dataType - The data type
     * @param options - The options
     * @param abortSignal - The abort signal
     */
    async sendEvent(eventName, content, dataType, options) {
        return await this._operationExecuteWithRetry(() => this._sendEventAttempt(eventName, content, dataType, options), options === null || options === void 0 ? void 0 : options.abortSignal);
    }
    async _sendEventAttempt(eventName, content, dataType, options) {
        var _a;
        const fireAndForget = (_a = options === null || options === void 0 ? void 0 : options.fireAndForget) !== null && _a !== void 0 ? _a : false;
        if (!fireAndForget) {
            return await this._sendMessageWithAckId((id) => {
                return {
                    kind: "sendEvent",
                    dataType: dataType,
                    data: content,
                    ackId: id,
                    event: eventName,
                };
            }, options === null || options === void 0 ? void 0 : options.ackId, options === null || options === void 0 ? void 0 : options.abortSignal);
        }
        const message = {
            kind: "sendEvent",
            dataType: dataType,
            data: content,
            event: eventName,
        };
        await this._sendMessage(message, options === null || options === void 0 ? void 0 : options.abortSignal);
        return { isDuplicated: false };
    }
    /**
     * Join the client to group
     * @param groupName - The group name
     * @param options - The join group options
     */
    async joinGroup(groupName, options) {
        return await this._operationExecuteWithRetry(() => this._joinGroupAttempt(groupName, options), options === null || options === void 0 ? void 0 : options.abortSignal);
    }
    async _joinGroupAttempt(groupName, options) {
        const group = this._getOrAddGroup(groupName);
        const result = await this._joinGroupCore(groupName, options);
        group.isJoined = true;
        return result;
    }
    async _joinGroupCore(groupName, options) {
        return await this._sendMessageWithAckId((id) => {
            return {
                group: groupName,
                ackId: id,
                kind: "joinGroup",
            };
        }, options === null || options === void 0 ? void 0 : options.ackId, options === null || options === void 0 ? void 0 : options.abortSignal);
    }
    /**
     * Leave the client from group
     * @param groupName - The group name
     * @param ackId - The optional ackId. If not specified, client will generate one.
     * @param abortSignal - The abort signal
     */
    async leaveGroup(groupName, options) {
        return await this._operationExecuteWithRetry(() => this._leaveGroupAttempt(groupName, options), options === null || options === void 0 ? void 0 : options.abortSignal);
    }
    async _leaveGroupAttempt(groupName, options) {
        const group = this._getOrAddGroup(groupName);
        const result = await this._sendMessageWithAckId((id) => {
            return {
                group: groupName,
                ackId: id,
                kind: "leaveGroup",
            };
        }, options === null || options === void 0 ? void 0 : options.ackId, options === null || options === void 0 ? void 0 : options.abortSignal);
        group.isJoined = false;
        return result;
    }
    /**
     * Send message to group.
     * @param groupName - The group name
     * @param content - The data content
     * @param dataType - The data type
     * @param options - The options
     * @param abortSignal - The abort signal
     */
    async sendToGroup(groupName, content, dataType, options) {
        return await this._operationExecuteWithRetry(() => this._sendToGroupAttempt(groupName, content, dataType, options), options === null || options === void 0 ? void 0 : options.abortSignal);
    }
    async _sendToGroupAttempt(groupName, content, dataType, options) {
        var _a, _b;
        const fireAndForget = (_a = options === null || options === void 0 ? void 0 : options.fireAndForget) !== null && _a !== void 0 ? _a : false;
        const noEcho = (_b = options === null || options === void 0 ? void 0 : options.noEcho) !== null && _b !== void 0 ? _b : false;
        if (!fireAndForget) {
            return await this._sendMessageWithAckId((id) => {
                return {
                    kind: "sendToGroup",
                    group: groupName,
                    dataType: dataType,
                    data: content,
                    ackId: id,
                    noEcho: noEcho,
                };
            }, options === null || options === void 0 ? void 0 : options.ackId, options === null || options === void 0 ? void 0 : options.abortSignal);
        }
        const message = {
            kind: "sendToGroup",
            group: groupName,
            dataType: dataType,
            data: content,
            noEcho: noEcho,
        };
        await this._sendMessage(message, options === null || options === void 0 ? void 0 : options.abortSignal);
        return { isDuplicated: false };
    }
    _getWebSocketClientFactory() {
        return new WebSocketClientFactory();
    }
    async _trySendSequenceAck() {
        if (!this._protocol.isReliableSubProtocol) {
            return;
        }
        const [isUpdated, seqId] = this._sequenceId.tryGetSequenceId();
        if (isUpdated && seqId) {
            const message = {
                kind: "sequenceAck",
                sequenceId: seqId,
            };
            try {
                await this._sendMessage(message);
            }
            catch (_a) {
                this._sequenceId.tryUpdate(seqId); // If sending failed, mark it as updated so that it can be sent again.
            }
        }
    }
    _connectCore(uri) {
        if (this._isStopping) {
            throw new Error("Can't start a client during stopping");
        }
        return new Promise((resolve, reject) => {
            // This part is executed sync
            const client = (this._wsClient = this._getWebSocketClientFactory().create(uri, this._protocol.name));
            client.onopen(() => {
                // There's a case that client called stop() before this method. We need to check and close it if it's the case.
                if (this._isStopping) {
                    try {
                        client.close();
                    }
                    catch (_a) { }
                    reject(new Error(`The client is stopped`));
                }
                logger.verbose("WebSocket connection has opened");
                this._changeState(WebPubSubClientState.Connected);
                if (this._protocol.isReliableSubProtocol) {
                    if (this._sequenceAckTask != null) {
                        this._sequenceAckTask.abort();
                    }
                    this._sequenceAckTask = new AbortableTask(async () => {
                        await this._trySendSequenceAck();
                    }, 1000);
                }
                resolve();
            });
            client.onerror((e) => {
                if (this._sequenceAckTask != null) {
                    this._sequenceAckTask.abort();
                }
                reject(e);
            });
            client.onclose((code, reason) => {
                if (this._state === WebPubSubClientState.Connected) {
                    logger.verbose("WebSocket closed after open");
                    if (this._sequenceAckTask != null) {
                        this._sequenceAckTask.abort();
                    }
                    logger.info(`WebSocket connection closed. Code: ${code}, Reason: ${reason}`);
                    this._lastCloseEvent = { code: code, reason: reason };
                    this._handleConnectionClose.call(this);
                }
                else {
                    logger.verbose("WebSocket closed before open");
                    reject(new Error(`Failed to start WebSocket: ${code}`));
                }
            });
            client.onmessage((data) => {
                const handleAckMessage = (message) => {
                    if (this._ackMap.has(message.ackId)) {
                        const entity = this._ackMap.get(message.ackId);
                        this._ackMap.delete(message.ackId);
                        const isDuplicated = message.error != null && message.error.name === "Duplicate";
                        if (message.success || isDuplicated) {
                            entity.resolve({
                                ackId: message.ackId,
                                isDuplicated: isDuplicated,
                            });
                        }
                        else {
                            entity.reject(new SendMessageError("Failed to send message.", {
                                ackId: message.ackId,
                                errorDetail: message.error,
                            }));
                        }
                    }
                };
                const handleConnectedMessage = async (message) => {
                    this._connectionId = message.connectionId;
                    this._reconnectionToken = message.reconnectionToken;
                    if (!this._isInitialConnected) {
                        this._isInitialConnected = true;
                        if (this._options.autoRejoinGroups) {
                            const groupPromises = [];
                            this._groupMap.forEach((g) => {
                                if (g.isJoined) {
                                    groupPromises.push((async () => {
                                        try {
                                            await this._joinGroupCore(g.name);
                                        }
                                        catch (err) {
                                            this._safeEmitRejoinGroupFailed(g.name, err);
                                        }
                                    })());
                                }
                            });
                            try {
                                await Promise.all(groupPromises);
                            }
                            catch (_a) { }
                        }
                        this._safeEmitConnected(message.connectionId, message.userId);
                    }
                };
                const handleDisconnectedMessage = (message) => {
                    this._lastDisconnectedMessage = message;
                };
                const handleGroupDataMessage = (message) => {
                    if (message.sequenceId != null) {
                        const diff = this._sequenceId.tryUpdate(message.sequenceId);
                        if (diff === 0) {
                            // drop duplicated message
                            return;
                        }
                        // If the diff is larger than the threshold, we must ack quicker to avoid slow client drop.
                        if (diff > this._quickSequenceAckDiff) {
                            this._trySendSequenceAck();
                        }
                    }
                    this._safeEmitGroupMessage(message);
                };
                const handleServerDataMessage = (message) => {
                    if (message.sequenceId != null) {
                        const diff = this._sequenceId.tryUpdate(message.sequenceId);
                        if (diff === 0) {
                            // drop duplicated message
                            return;
                        }
                        // If the diff is larger than the threshold, we must ack quicker to avoid slow client drop.
                        if (diff > this._quickSequenceAckDiff) {
                            this._trySendSequenceAck();
                        }
                    }
                    this._safeEmitServerMessage(message);
                };
                let messages;
                try {
                    let convertedData;
                    if (Array.isArray(data)) {
                        convertedData = Buffer.concat(data);
                    }
                    else {
                        convertedData = data;
                    }
                    messages = this._protocol.parseMessages(convertedData);
                    if (messages === null) {
                        // null means the message is not recognized.
                        return;
                    }
                }
                catch (err) {
                    logger.warning("An error occurred while parsing the message from service", err);
                    throw err;
                }
                if (!Array.isArray(messages)) {
                    messages = [messages];
                }
                messages.forEach((message) => {
                    try {
                        switch (message.kind) {
                            case "ack": {
                                handleAckMessage(message);
                                break;
                            }
                            case "connected": {
                                handleConnectedMessage(message);
                                break;
                            }
                            case "disconnected": {
                                handleDisconnectedMessage(message);
                                break;
                            }
                            case "groupData": {
                                handleGroupDataMessage(message);
                                break;
                            }
                            case "serverData": {
                                handleServerDataMessage(message);
                                break;
                            }
                        }
                    }
                    catch (err) {
                        logger.warning(`An error occurred while handling the message with kind: ${message.kind} from service`, err);
                    }
                });
            });
        });
    }
    async _handleConnectionCloseAndNoRecovery() {
        this._state = WebPubSubClientState.Disconnected;
        this._safeEmitDisconnected(this._connectionId, this._lastDisconnectedMessage);
        // Auto reconnect or stop
        if (this._options.autoReconnect) {
            await this._autoReconnect();
        }
        else {
            await this._handleConnectionStopped();
        }
    }
    async _autoReconnect() {
        let isSuccess = false;
        let attempt = 0;
        try {
            while (!this._isStopping) {
                try {
                    await this._startFromRestarting();
                    isSuccess = true;
                    break;
                }
                catch (err) {
                    logger.warning("An attempt to reconnect connection failed.", err);
                    attempt++;
                    const delayInMs = this._reconnectRetryPolicy.nextRetryDelayInMs(attempt);
                    if (delayInMs == null) {
                        break;
                    }
                    try {
                        logger.verbose(`Delay time for reconnect attempt ${attempt}: ${delayInMs}`);
                        await delay(delayInMs);
                    }
                    catch (_a) { }
                }
            }
        }
        finally {
            if (!isSuccess) {
                this._handleConnectionStopped();
            }
        }
    }
    _handleConnectionStopped() {
        this._isStopping = false;
        this._state = WebPubSubClientState.Stopped;
        this._safeEmitStopped();
    }
    _getActiveKeepaliveTask() {
        return new AbortableTask(async () => {
            this._sequenceId.tryUpdate(0); // force update
        }, this._activeTimeoutInMs);
    }
    async _sendMessage(message, abortSignal) {
        if (!this._wsClient || !this._wsClient.isOpen()) {
            throw new Error("The connection is not connected.");
        }
        const payload = this._protocol.writeMessage(message);
        await this._wsClient.send(payload, abortSignal);
    }
    async _sendMessageWithAckId(messageProvider, ackId, abortSignal) {
        if (ackId == null) {
            ackId = this.nextAckId();
        }
        const message = messageProvider(ackId);
        if (!this._ackMap.has(ackId)) {
            this._ackMap.set(ackId, new AckEntity(ackId));
        }
        const entity = this._ackMap.get(ackId);
        try {
            await this._sendMessage(message, abortSignal);
        }
        catch (error) {
            this._ackMap.delete(ackId);
            let errorMessage = "";
            if (error instanceof Error) {
                errorMessage = error.message;
            }
            throw new SendMessageError(errorMessage, { ackId: ackId });
        }
        if (abortSignal) {
            try {
                return await abortablePromise(entity.promise(), abortSignal);
            }
            catch (err) {
                if (err instanceof Error && err.name === "AbortError") {
                    throw new SendMessageError("Cancelled by abortSignal", { ackId: ackId });
                }
                throw err;
            }
        }
        return await entity.promise();
    }
    async _handleConnectionClose() {
        // Clean ack cache
        this._ackMap.forEach((value, key) => {
            if (this._ackMap.delete(key)) {
                value.reject(new SendMessageError("Connection is disconnected before receive ack from the service", {
                    ackId: value.ackId,
                }));
            }
        });
        if (this._isStopping) {
            logger.warning("The client is stopping state. Stop recovery.");
            this._handleConnectionCloseAndNoRecovery();
            return;
        }
        if (this._lastCloseEvent && this._lastCloseEvent.code === 1008) {
            logger.warning("The websocket close with status code 1008. Stop recovery.");
            this._handleConnectionCloseAndNoRecovery();
            return;
        }
        if (!this._protocol.isReliableSubProtocol) {
            logger.warning("The protocol is not reliable, recovery is not applicable");
            this._handleConnectionCloseAndNoRecovery();
            return;
        }
        // Build recovery uri
        const recoveryUri = this._buildRecoveryUri();
        if (!recoveryUri) {
            logger.warning("Connection id or reconnection token is not available");
            this._handleConnectionCloseAndNoRecovery();
            return;
        }
        // Try recover connection
        let recovered = false;
        this._state = WebPubSubClientState.Recovering;
        const abortSignal = AbortController.timeout(30 * 1000);
        try {
            while (!abortSignal.aborted || this._isStopping) {
                try {
                    await this._connectCore.call(this, recoveryUri);
                    recovered = true;
                    return;
                }
                catch (_a) {
                    await delay(1000);
                }
            }
        }
        finally {
            if (!recovered) {
                logger.warning("Recovery attempts failed more then 30 seconds or the client is stopping");
                this._handleConnectionCloseAndNoRecovery();
            }
        }
    }
    _safeEmitConnected(connectionId, userId) {
        this._emitEvent("connected", {
            connectionId: connectionId,
            userId: userId,
        });
    }
    _safeEmitDisconnected(connectionId, lastDisconnectedMessage) {
        this._emitEvent("disconnected", {
            connectionId: connectionId,
            message: lastDisconnectedMessage,
        });
    }
    _safeEmitGroupMessage(message) {
        this._emitEvent("group-message", {
            message: message,
        });
    }
    _safeEmitServerMessage(message) {
        this._emitEvent("server-message", {
            message: message,
        });
    }
    _safeEmitStopped() {
        this._emitEvent("stopped", {});
    }
    _safeEmitRejoinGroupFailed(groupName, err) {
        this._emitEvent("rejoin-group-failed", {
            group: groupName,
            error: err,
        });
    }
    _buildDefaultOptions(clientOptions) {
        if (clientOptions.autoReconnect == null) {
            clientOptions.autoReconnect = true;
        }
        if (clientOptions.autoRejoinGroups == null) {
            clientOptions.autoRejoinGroups = true;
        }
        if (clientOptions.protocol == null) {
            clientOptions.protocol = WebPubSubJsonReliableProtocol();
        }
        this._buildMessageRetryOptions(clientOptions);
        this._buildReconnectRetryOptions(clientOptions);
        return clientOptions;
    }
    _buildMessageRetryOptions(clientOptions) {
        if (!clientOptions.messageRetryOptions) {
            clientOptions.messageRetryOptions = {};
        }
        if (clientOptions.messageRetryOptions.maxRetries == null ||
            clientOptions.messageRetryOptions.maxRetries < 0) {
            clientOptions.messageRetryOptions.maxRetries = 3;
        }
        if (clientOptions.messageRetryOptions.retryDelayInMs == null ||
            clientOptions.messageRetryOptions.retryDelayInMs < 0) {
            clientOptions.messageRetryOptions.retryDelayInMs = 1000;
        }
        if (clientOptions.messageRetryOptions.maxRetryDelayInMs == null ||
            clientOptions.messageRetryOptions.maxRetryDelayInMs < 0) {
            clientOptions.messageRetryOptions.maxRetryDelayInMs = 30000;
        }
        if (clientOptions.messageRetryOptions.mode == null) {
            clientOptions.messageRetryOptions.mode = "Fixed";
        }
    }
    _buildReconnectRetryOptions(clientOptions) {
        if (!clientOptions.reconnectRetryOptions) {
            clientOptions.reconnectRetryOptions = {};
        }
        if (clientOptions.reconnectRetryOptions.maxRetries == null ||
            clientOptions.reconnectRetryOptions.maxRetries < 0) {
            clientOptions.reconnectRetryOptions.maxRetries = Number.MAX_VALUE;
        }
        if (clientOptions.reconnectRetryOptions.retryDelayInMs == null ||
            clientOptions.reconnectRetryOptions.retryDelayInMs < 0) {
            clientOptions.reconnectRetryOptions.retryDelayInMs = 1000;
        }
        if (clientOptions.reconnectRetryOptions.maxRetryDelayInMs == null ||
            clientOptions.reconnectRetryOptions.maxRetryDelayInMs < 0) {
            clientOptions.reconnectRetryOptions.maxRetryDelayInMs = 30000;
        }
        if (clientOptions.reconnectRetryOptions.mode == null) {
            clientOptions.reconnectRetryOptions.mode = "Fixed";
        }
    }
    _buildRecoveryUri() {
        if (this._connectionId && this._reconnectionToken && this._uri) {
            const url = new URL(this._uri);
            url.searchParams.append("awps_connection_id", this._connectionId);
            url.searchParams.append("awps_reconnection_token", this._reconnectionToken);
            return url.toString();
        }
        return null;
    }
    _getOrAddGroup(name) {
        if (!this._groupMap.has(name)) {
            this._groupMap.set(name, new WebPubSubGroup(name));
        }
        return this._groupMap.get(name);
    }
    _changeState(newState) {
        logger.verbose(`The client state transfer from ${this._state.toString()} to ${newState.toString()}`);
        this._state = newState;
    }
    async _operationExecuteWithRetry(inner, signal) {
        let retryAttempt = 0;
        while (true) {
            try {
                return await inner.call(this);
            }
            catch (err) {
                retryAttempt++;
                const delayInMs = this._messageRetryPolicy.nextRetryDelayInMs(retryAttempt);
                if (delayInMs == null) {
                    throw err;
                }
                await delay(delayInMs);
                if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
                    throw err;
                }
            }
        }
    }
}
class RetryPolicy {
    constructor(retryOptions) {
        this._retryOptions = retryOptions;
        this._maxRetriesToGetMaxDelay = Math.ceil(Math.log2(this._retryOptions.maxRetryDelayInMs) -
            Math.log2(this._retryOptions.retryDelayInMs) +
            1);
    }
    nextRetryDelayInMs(retryAttempt) {
        if (retryAttempt > this._retryOptions.maxRetries) {
            return null;
        }
        else {
            if (this._retryOptions.mode === "Fixed") {
                return this._retryOptions.retryDelayInMs;
            }
            else {
                return this._calculateExponentialDelay(retryAttempt);
            }
        }
    }
    _calculateExponentialDelay(attempt) {
        if (attempt >= this._maxRetriesToGetMaxDelay) {
            return this._retryOptions.maxRetryDelayInMs;
        }
        else {
            return (1 << (attempt - 1)) * this._retryOptions.retryDelayInMs;
        }
    }
}
class WebPubSubGroup {
    constructor(name) {
        this.isJoined = false;
        this.name = name;
    }
}
class AckEntity {
    constructor(ackId) {
        this._promise = new Promise((resolve, reject) => {
            this._resolve = resolve;
            this._reject = reject;
        });
        this.ackId = ackId;
    }
    promise() {
        return this._promise;
    }
    resolve(value) {
        this._resolve(value);
    }
    reject(reason) {
        this._reject(reason);
    }
}
class SequenceId {
    constructor() {
        this._sequenceId = 0;
        this._isUpdate = false;
    }
    tryUpdate(sequenceId) {
        this._isUpdate = true;
        if (sequenceId > this._sequenceId) {
            const diff = sequenceId - this._sequenceId;
            this._sequenceId = sequenceId;
            return diff;
        }
        return 0;
    }
    tryGetSequenceId() {
        if (this._isUpdate) {
            this._isUpdate = false;
            return [true, this._sequenceId];
        }
        return [false, null];
    }
    reset() {
        this._sequenceId = 0;
        this._isUpdate = false;
    }
}
class AbortableTask {
    constructor(func, interval, obj) {
        this._func = func;
        this._abortController = new AbortController();
        this._interval = interval;
        this._obj = obj;
        this._start();
    }
    abort() {
        try {
            this._abortController.abort();
        }
        catch (_a) { }
    }
    async _start() {
        const signal = this._abortController.signal;
        while (!signal.aborted) {
            try {
                await this._func(this._obj);
            }
            catch (_a) {
            }
            finally {
                await delay(this._interval);
            }
        }
    }
}
//# sourceMappingURL=webPubSubClient.js.map