// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { Buffer } from "buffer";
export function parseMessages(input) {
    // The interface does allow "ArrayBuffer" to be passed in, but this implementation does not. So let's throw a useful error.
    if (typeof input !== "string") {
        throw new Error("Invalid input for JSON hub protocol. Expected a string.");
    }
    if (!input) {
        throw new Error("No input");
    }
    const parsedMessage = JSON.parse(input);
    const typedMessage = parsedMessage;
    let returnMessage;
    if (typedMessage.type === "system") {
        if (typedMessage.event === "connected") {
            returnMessage = Object.assign(Object.assign({}, parsedMessage), { kind: "connected" });
        }
        else if (typedMessage.event === "disconnected") {
            returnMessage = Object.assign(Object.assign({}, parsedMessage), { kind: "disconnected" });
        }
        else {
            // Forward compatible
            return null;
        }
    }
    else if (typedMessage.type === "message") {
        if (typedMessage.from === "group") {
            const data = parsePayload(parsedMessage.data, parsedMessage.dataType);
            if (data === null) {
                return null;
            }
            returnMessage = Object.assign(Object.assign({}, parsedMessage), { data: data, kind: "groupData" });
        }
        else if (typedMessage.from === "server") {
            const data = parsePayload(parsedMessage.data, parsedMessage.dataType);
            if (data === null) {
                return null;
            }
            returnMessage = Object.assign(Object.assign({}, parsedMessage), { data: data, kind: "serverData" });
        }
        else {
            // Forward compatible
            return null;
        }
    }
    else if (typedMessage.type === "ack") {
        returnMessage = Object.assign(Object.assign({}, parsedMessage), { kind: "ack" });
    }
    else {
        // Forward compatible
        return null;
    }
    return returnMessage;
}
export function writeMessage(message) {
    let data;
    switch (message.kind) {
        case "joinGroup": {
            data = { type: "joinGroup", group: message.group, ackId: message.ackId };
            break;
        }
        case "leaveGroup": {
            data = { type: "leaveGroup", group: message.group, ackId: message.ackId };
            break;
        }
        case "sendEvent": {
            data = {
                type: "event",
                event: message.event,
                ackId: message.ackId,
                dataType: message.dataType,
                data: getPayload(message.data, message.dataType),
            };
            break;
        }
        case "sendToGroup": {
            data = {
                type: "sendToGroup",
                group: message.group,
                ackId: message.ackId,
                dataType: message.dataType,
                data: getPayload(message.data, message.dataType),
                noEcho: message.noEcho,
            };
            break;
        }
        case "sequenceAck": {
            data = { type: "sequenceAck", sequenceId: message.sequenceId };
            break;
        }
        default: {
            throw new Error(`Unsupported type: ${message.kind}`);
        }
    }
    return JSON.stringify(data);
}
function getPayload(data, dataType) {
    switch (dataType) {
        case "text": {
            if (typeof data !== "string") {
                throw new TypeError("Message must be a string.");
            }
            return data;
        }
        case "json": {
            return data;
        }
        case "binary":
        case "protobuf": {
            if (data instanceof ArrayBuffer) {
                return Buffer.from(data).toString("base64");
            }
            throw new TypeError("Message must be a ArrayBuffer");
        }
    }
}
function parsePayload(data, dataType) {
    if (dataType === "text") {
        if (typeof data !== "string") {
            throw new TypeError("Message must be a string when dataType is text");
        }
        return data;
    }
    else if (dataType === "json") {
        return data;
    }
    else if (dataType === "binary" || dataType === "protobuf") {
        const buf = Buffer.from(data, "base64");
        return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    }
    else {
        // Forward compatible
        return null;
    }
}
//# sourceMappingURL=jsonProtocolBase.js.map