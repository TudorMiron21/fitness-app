'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var coreAuth = require('@azure/core-auth');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreClient = require('@azure/core-client');
var coreTracing = require('@azure/core-tracing');
var jwt = require('jsonwebtoken');
var logger$1 = require('@azure/logger');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespace(coreClient);
var jwt__default = /*#__PURE__*/_interopDefaultLegacy(jwt);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const ErrorDetail = {
    type: {
        name: "Composite",
        className: "ErrorDetail",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorDetail"
                        }
                    }
                }
            },
            inner: {
                serializedName: "inner",
                type: {
                    name: "Composite",
                    className: "InnerError"
                }
            }
        }
    }
};
const InnerError = {
    type: {
        name: "Composite",
        className: "InnerError",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            inner: {
                serializedName: "inner",
                type: {
                    name: "Composite",
                    className: "InnerError"
                }
            }
        }
    }
};
const ClientTokenResponse = {
    type: {
        name: "Composite",
        className: "ClientTokenResponse",
        modelProperties: {
            token: {
                serializedName: "token",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubCloseAllConnectionsExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubCloseAllConnectionsExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubGenerateClientTokenExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubGenerateClientTokenExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubSendToAllExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubSendToAllExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubCloseConnectionExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubCloseConnectionExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubConnectionExistsExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubConnectionExistsExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubSendToConnectionExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubSendToConnectionExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubRemoveConnectionFromAllGroupsExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubRemoveConnectionFromAllGroupsExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubGroupExistsExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubGroupExistsExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubCloseGroupConnectionsExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubCloseGroupConnectionsExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubSendToGroupExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubSendToGroupExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubRemoveConnectionFromGroupExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubRemoveConnectionFromGroupExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubAddConnectionToGroupExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubAddConnectionToGroupExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubRevokePermissionExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubRevokePermissionExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubCheckPermissionExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubCheckPermissionExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubGrantPermissionExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubGrantPermissionExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubUserExistsExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubUserExistsExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubCloseUserConnectionsExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubCloseUserConnectionsExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubSendToUserExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubSendToUserExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubRemoveUserFromAllGroupsExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubRemoveUserFromAllGroupsExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubRemoveUserFromGroupExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubRemoveUserFromGroupExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubAddUserToGroupExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubAddUserToGroupExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ErrorDetail: ErrorDetail,
    InnerError: InnerError,
    ClientTokenResponse: ClientTokenResponse,
    WebPubSubCloseAllConnectionsExceptionHeaders: WebPubSubCloseAllConnectionsExceptionHeaders,
    WebPubSubGenerateClientTokenExceptionHeaders: WebPubSubGenerateClientTokenExceptionHeaders,
    WebPubSubSendToAllExceptionHeaders: WebPubSubSendToAllExceptionHeaders,
    WebPubSubCloseConnectionExceptionHeaders: WebPubSubCloseConnectionExceptionHeaders,
    WebPubSubConnectionExistsExceptionHeaders: WebPubSubConnectionExistsExceptionHeaders,
    WebPubSubSendToConnectionExceptionHeaders: WebPubSubSendToConnectionExceptionHeaders,
    WebPubSubRemoveConnectionFromAllGroupsExceptionHeaders: WebPubSubRemoveConnectionFromAllGroupsExceptionHeaders,
    WebPubSubGroupExistsExceptionHeaders: WebPubSubGroupExistsExceptionHeaders,
    WebPubSubCloseGroupConnectionsExceptionHeaders: WebPubSubCloseGroupConnectionsExceptionHeaders,
    WebPubSubSendToGroupExceptionHeaders: WebPubSubSendToGroupExceptionHeaders,
    WebPubSubRemoveConnectionFromGroupExceptionHeaders: WebPubSubRemoveConnectionFromGroupExceptionHeaders,
    WebPubSubAddConnectionToGroupExceptionHeaders: WebPubSubAddConnectionToGroupExceptionHeaders,
    WebPubSubRevokePermissionExceptionHeaders: WebPubSubRevokePermissionExceptionHeaders,
    WebPubSubCheckPermissionExceptionHeaders: WebPubSubCheckPermissionExceptionHeaders,
    WebPubSubGrantPermissionExceptionHeaders: WebPubSubGrantPermissionExceptionHeaders,
    WebPubSubUserExistsExceptionHeaders: WebPubSubUserExistsExceptionHeaders,
    WebPubSubCloseUserConnectionsExceptionHeaders: WebPubSubCloseUserConnectionsExceptionHeaders,
    WebPubSubSendToUserExceptionHeaders: WebPubSubSendToUserExceptionHeaders,
    WebPubSubRemoveUserFromAllGroupsExceptionHeaders: WebPubSubRemoveUserFromAllGroupsExceptionHeaders,
    WebPubSubRemoveUserFromGroupExceptionHeaders: WebPubSubRemoveUserFromGroupExceptionHeaders,
    WebPubSubAddUserToGroupExceptionHeaders: WebPubSubAddUserToGroupExceptionHeaders
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const endpoint = {
    parameterPath: "endpoint",
    mapper: {
        serializedName: "Endpoint",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2022-11-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const hub = {
    parameterPath: "hub",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[A-Za-z][A-Za-z0-9_`,.[\\]]{0,127}$")
        },
        serializedName: "hub",
        required: true,
        type: {
            name: "String"
        }
    }
};
const excluded = {
    parameterPath: ["options", "excluded"],
    mapper: {
        serializedName: "excluded",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "Multi"
};
const reason = {
    parameterPath: ["options", "reason"],
    mapper: {
        serializedName: "reason",
        type: {
            name: "String"
        }
    }
};
const accept1 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json, text/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const userId = {
    parameterPath: ["options", "userId"],
    mapper: {
        serializedName: "userId",
        type: {
            name: "String"
        }
    }
};
const roles = {
    parameterPath: ["options", "roles"],
    mapper: {
        serializedName: "role",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "Multi"
};
const expirationTimeInMinutes = {
    parameterPath: ["options", "expirationTimeInMinutes"],
    mapper: {
        defaultValue: 60,
        constraints: {
            InclusiveMinimum: 1
        },
        serializedName: "minutesToExpire",
        type: {
            name: "Number"
        }
    }
};
const groups = {
    parameterPath: ["options", "groups"],
    mapper: {
        serializedName: "group",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "Multi"
};
const contentType = {
    parameterPath: "contentType",
    mapper: {
        serializedName: "Content-Type",
        required: true,
        type: {
            name: "Enum",
            allowedValues: ["application/json", "application/octet-stream"]
        }
    }
};
const message = {
    parameterPath: "message",
    mapper: {
        serializedName: "message",
        required: true,
        type: {
            name: "Stream"
        }
    }
};
const accept2 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const contentType1 = {
    parameterPath: "contentType",
    mapper: {
        defaultValue: "text/plain",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const message1 = {
    parameterPath: "message",
    mapper: {
        serializedName: "message",
        required: true,
        type: {
            name: "String"
        }
    }
};
const accept3 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const excludedConnections = {
    parameterPath: ["options", "excludedConnections"],
    mapper: {
        serializedName: "excluded",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "Multi"
};
const filter = {
    parameterPath: ["options", "filter"],
    mapper: {
        serializedName: "filter",
        type: {
            name: "String"
        }
    }
};
const connectionId = {
    parameterPath: "connectionId",
    mapper: {
        constraints: {
            MinLength: 1
        },
        serializedName: "connectionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const group = {
    parameterPath: "group",
    mapper: {
        constraints: {
            Pattern: new RegExp("^(?!\\s+$).+$"),
            MaxLength: 1024,
            MinLength: 1
        },
        serializedName: "group",
        required: true,
        type: {
            name: "String"
        }
    }
};
const permission = {
    parameterPath: "permission",
    mapper: {
        serializedName: "permission",
        required: true,
        type: {
            name: "String"
        }
    }
};
const targetName = {
    parameterPath: ["options", "targetName"],
    mapper: {
        serializedName: "targetName",
        type: {
            name: "String"
        }
    }
};
const userId1 = {
    parameterPath: "userId",
    mapper: {
        constraints: {
            MinLength: 1
        },
        serializedName: "userId",
        required: true,
        type: {
            name: "String"
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing HealthApi operations. */
class HealthApiImpl {
    /**
     * Initialize a new instance of the class HealthApi class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get service health status.
     * @param options The options parameters.
     */
    getServiceStatus(options) {
        return this.client.sendOperationRequest({ options }, getServiceStatusOperationSpec);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getServiceStatusOperationSpec = {
    path: "/api/health",
    httpMethod: "HEAD",
    responses: { 200: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [endpoint],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing WebPubSub operations. */
class WebPubSubImpl {
    /**
     * Initialize a new instance of the class WebPubSub class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Close the connections in the hub.
     * @param hub Target hub name, which should start with alphabetic characters and only contain
     *            alpha-numeric characters or underscore.
     * @param options The options parameters.
     */
    closeAllConnections(hub, options) {
        return this.client.sendOperationRequest({ hub, options }, closeAllConnectionsOperationSpec);
    }
    /**
     * Generate token for the client to connect Azure Web PubSub service.
     * @param hub Target hub name, which should start with alphabetic characters and only contain
     *            alpha-numeric characters or underscore.
     * @param options The options parameters.
     */
    generateClientToken(hub, options) {
        return this.client.sendOperationRequest({ hub, options }, generateClientTokenOperationSpec);
    }
    /**
     * Broadcast content inside request body to all the connected client connections.
     * @param args Includes all the parameters for this operation.
     */
    sendToAll(...args) {
        let operationSpec;
        let operationArguments;
        let options;
        if (args[1] === "application/json" ||
            args[1] === "application/octet-stream") {
            operationSpec = sendToAll$binaryOperationSpec;
            operationArguments = {
                hub: args[0],
                contentType: args[1],
                message: args[2],
                options: args[3]
            };
            options = args[3];
        }
        else if (args[1] === "text/plain") {
            operationSpec = sendToAll$textOperationSpec;
            operationArguments = {
                hub: args[0],
                contentType: args[1],
                message: args[2],
                options: args[3]
            };
            options = args[3];
        }
        else {
            throw new TypeError(`"contentType" must be a valid value but instead was "${args[1]}".`);
        }
        operationArguments.options = options || {};
        return this.client.sendOperationRequest(operationArguments, operationSpec);
    }
    /**
     * Close the client connection.
     * @param hub Target hub name, which should start with alphabetic characters and only contain
     *            alpha-numeric characters or underscore.
     * @param connectionId Target connection Id.
     * @param options The options parameters.
     */
    closeConnection(hub, connectionId, options) {
        return this.client.sendOperationRequest({ hub, connectionId, options }, closeConnectionOperationSpec);
    }
    /**
     * Check if the connection with the given connectionId exists.
     * @param hub Target hub name, which should start with alphabetic characters and only contain
     *            alpha-numeric characters or underscore.
     * @param connectionId The connection Id.
     * @param options The options parameters.
     */
    connectionExists(hub, connectionId, options) {
        return this.client.sendOperationRequest({ hub, connectionId, options }, connectionExistsOperationSpec);
    }
    /**
     * Send content inside request body to the specific connection.
     * @param args Includes all the parameters for this operation.
     */
    sendToConnection(...args) {
        let operationSpec;
        let operationArguments;
        let options;
        if (args[2] === "application/json" ||
            args[2] === "application/octet-stream") {
            operationSpec = sendToConnection$binaryOperationSpec;
            operationArguments = {
                hub: args[0],
                connectionId: args[1],
                contentType: args[2],
                message: args[3],
                options: args[4]
            };
            options = args[4];
        }
        else if (args[2] === "text/plain") {
            operationSpec = sendToConnection$textOperationSpec;
            operationArguments = {
                hub: args[0],
                connectionId: args[1],
                contentType: args[2],
                message: args[3],
                options: args[4]
            };
            options = args[4];
        }
        else {
            throw new TypeError(`"contentType" must be a valid value but instead was "${args[2]}".`);
        }
        operationArguments.options = options || {};
        return this.client.sendOperationRequest(operationArguments, operationSpec);
    }
    /**
     * Remove a connection from all groups.
     * @param hub Target hub name, which should start with alphabetic characters and only contain
     *            alpha-numeric characters or underscore.
     * @param connectionId Target connection Id.
     * @param options The options parameters.
     */
    removeConnectionFromAllGroups(hub, connectionId, options) {
        return this.client.sendOperationRequest({ hub, connectionId, options }, removeConnectionFromAllGroupsOperationSpec);
    }
    /**
     * Check if there are any client connections inside the given group
     * @param hub Target hub name, which should start with alphabetic characters and only contain
     *            alpha-numeric characters or underscore.
     * @param group Target group name, which length should be greater than 0 and less than 1025.
     * @param options The options parameters.
     */
    groupExists(hub, group, options) {
        return this.client.sendOperationRequest({ hub, group, options }, groupExistsOperationSpec);
    }
    /**
     * Close connections in the specific group.
     * @param hub Target hub name, which should start with alphabetic characters and only contain
     *            alpha-numeric characters or underscore.
     * @param group Target group name, which length should be greater than 0 and less than 1025.
     * @param options The options parameters.
     */
    closeGroupConnections(hub, group, options) {
        return this.client.sendOperationRequest({ hub, group, options }, closeGroupConnectionsOperationSpec);
    }
    /**
     * Send content inside request body to a group of connections.
     * @param args Includes all the parameters for this operation.
     */
    sendToGroup(...args) {
        let operationSpec;
        let operationArguments;
        let options;
        if (args[2] === "application/json" ||
            args[2] === "application/octet-stream") {
            operationSpec = sendToGroup$binaryOperationSpec;
            operationArguments = {
                hub: args[0],
                group: args[1],
                contentType: args[2],
                message: args[3],
                options: args[4]
            };
            options = args[4];
        }
        else if (args[2] === "text/plain") {
            operationSpec = sendToGroup$textOperationSpec;
            operationArguments = {
                hub: args[0],
                group: args[1],
                contentType: args[2],
                message: args[3],
                options: args[4]
            };
            options = args[4];
        }
        else {
            throw new TypeError(`"contentType" must be a valid value but instead was "${args[2]}".`);
        }
        operationArguments.options = options || {};
        return this.client.sendOperationRequest(operationArguments, operationSpec);
    }
    /**
     * Remove a connection from the target group.
     * @param hub Target hub name, which should start with alphabetic characters and only contain
     *            alpha-numeric characters or underscore.
     * @param group Target group name, which length should be greater than 0 and less than 1025.
     * @param connectionId Target connection Id.
     * @param options The options parameters.
     */
    removeConnectionFromGroup(hub, group, connectionId, options) {
        return this.client.sendOperationRequest({ hub, group, connectionId, options }, removeConnectionFromGroupOperationSpec);
    }
    /**
     * Add a connection to the target group.
     * @param hub Target hub name, which should start with alphabetic characters and only contain
     *            alpha-numeric characters or underscore.
     * @param group Target group name, which length should be greater than 0 and less than 1025.
     * @param connectionId Target connection Id
     * @param options The options parameters.
     */
    addConnectionToGroup(hub, group, connectionId, options) {
        return this.client.sendOperationRequest({ hub, group, connectionId, options }, addConnectionToGroupOperationSpec);
    }
    /**
     * Revoke permission for the connection.
     * @param hub Target hub name, which should start with alphabetic characters and only contain
     *            alpha-numeric characters or underscore.
     * @param permission The permission: current supported actions are joinLeaveGroup and sendToGroup.
     * @param connectionId Target connection Id.
     * @param options The options parameters.
     */
    revokePermission(hub, permission, connectionId, options) {
        return this.client.sendOperationRequest({ hub, permission, connectionId, options }, revokePermissionOperationSpec);
    }
    /**
     * Check if a connection has permission to the specified action.
     * @param hub Target hub name, which should start with alphabetic characters and only contain
     *            alpha-numeric characters or underscore.
     * @param permission The permission: current supported actions are joinLeaveGroup and sendToGroup.
     * @param connectionId Target connection Id.
     * @param options The options parameters.
     */
    checkPermission(hub, permission, connectionId, options) {
        return this.client.sendOperationRequest({ hub, permission, connectionId, options }, checkPermissionOperationSpec);
    }
    /**
     * Grant permission to the connection.
     * @param hub Target hub name, which should start with alphabetic characters and only contain
     *            alpha-numeric characters or underscore.
     * @param permission The permission: current supported actions are joinLeaveGroup and sendToGroup.
     * @param connectionId Target connection Id.
     * @param options The options parameters.
     */
    grantPermission(hub, permission, connectionId, options) {
        return this.client.sendOperationRequest({ hub, permission, connectionId, options }, grantPermissionOperationSpec);
    }
    /**
     * Check if there are any client connections connected for the given user.
     * @param hub Target hub name, which should start with alphabetic characters and only contain
     *            alpha-numeric characters or underscore.
     * @param userId Target user Id.
     * @param options The options parameters.
     */
    userExists(hub, userId, options) {
        return this.client.sendOperationRequest({ hub, userId, options }, userExistsOperationSpec);
    }
    /**
     * Close connections for the specific user.
     * @param hub Target hub name, which should start with alphabetic characters and only contain
     *            alpha-numeric characters or underscore.
     * @param userId The user Id.
     * @param options The options parameters.
     */
    closeUserConnections(hub, userId, options) {
        return this.client.sendOperationRequest({ hub, userId, options }, closeUserConnectionsOperationSpec);
    }
    /**
     * Send content inside request body to the specific user.
     * @param args Includes all the parameters for this operation.
     */
    sendToUser(...args) {
        let operationSpec;
        let operationArguments;
        let options;
        if (args[2] === "application/json" ||
            args[2] === "application/octet-stream") {
            operationSpec = sendToUser$binaryOperationSpec;
            operationArguments = {
                hub: args[0],
                userId: args[1],
                contentType: args[2],
                message: args[3],
                options: args[4]
            };
            options = args[4];
        }
        else if (args[2] === "text/plain") {
            operationSpec = sendToUser$textOperationSpec;
            operationArguments = {
                hub: args[0],
                userId: args[1],
                contentType: args[2],
                message: args[3],
                options: args[4]
            };
            options = args[4];
        }
        else {
            throw new TypeError(`"contentType" must be a valid value but instead was "${args[2]}".`);
        }
        operationArguments.options = options || {};
        return this.client.sendOperationRequest(operationArguments, operationSpec);
    }
    /**
     * Remove a user from all groups.
     * @param hub Target hub name, which should start with alphabetic characters and only contain
     *            alpha-numeric characters or underscore.
     * @param userId Target user Id.
     * @param options The options parameters.
     */
    removeUserFromAllGroups(hub, userId, options) {
        return this.client.sendOperationRequest({ hub, userId, options }, removeUserFromAllGroupsOperationSpec);
    }
    /**
     * Remove a user from the target group.
     * @param hub Target hub name, which should start with alphabetic characters and only contain
     *            alpha-numeric characters or underscore.
     * @param group Target group name, which length should be greater than 0 and less than 1025.
     * @param userId Target user Id.
     * @param options The options parameters.
     */
    removeUserFromGroup(hub, group, userId, options) {
        return this.client.sendOperationRequest({ hub, group, userId, options }, removeUserFromGroupOperationSpec);
    }
    /**
     * Add a user to the target group.
     * @param hub Target hub name, which should start with alphabetic characters and only contain
     *            alpha-numeric characters or underscore.
     * @param group Target group name, which length should be greater than 0 and less than 1025.
     * @param userId Target user Id.
     * @param options The options parameters.
     */
    addUserToGroup(hub, group, userId, options) {
        return this.client.sendOperationRequest({ hub, group, userId, options }, addUserToGroupOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const closeAllConnectionsOperationSpec = {
    path: "/api/hubs/{hub}/:closeConnections",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubCloseAllConnectionsExceptionHeaders
        }
    },
    queryParameters: [
        apiVersion,
        excluded,
        reason
    ],
    urlParameters: [endpoint, hub],
    headerParameters: [accept],
    serializer
};
const generateClientTokenOperationSpec = {
    path: "/api/hubs/{hub}/:generateToken",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ClientTokenResponse
        },
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubGenerateClientTokenExceptionHeaders
        }
    },
    queryParameters: [
        apiVersion,
        userId,
        roles,
        expirationTimeInMinutes,
        groups
    ],
    urlParameters: [endpoint, hub],
    headerParameters: [accept1],
    serializer
};
const sendToAll$binaryOperationSpec = {
    path: "/api/hubs/{hub}/:send",
    httpMethod: "POST",
    responses: {
        202: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubSendToAllExceptionHeaders
        }
    },
    requestBody: message,
    queryParameters: [
        apiVersion,
        excludedConnections,
        filter
    ],
    urlParameters: [endpoint, hub],
    headerParameters: [contentType, accept2],
    mediaType: "binary",
    serializer
};
const sendToAll$textOperationSpec = {
    path: "/api/hubs/{hub}/:send",
    httpMethod: "POST",
    responses: {
        202: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubSendToAllExceptionHeaders
        }
    },
    requestBody: message1,
    queryParameters: [
        apiVersion,
        excludedConnections,
        filter
    ],
    urlParameters: [endpoint, hub],
    headerParameters: [contentType1, accept3],
    mediaType: "text",
    serializer
};
const closeConnectionOperationSpec = {
    path: "/api/hubs/{hub}/connections/{connectionId}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubCloseConnectionExceptionHeaders
        }
    },
    queryParameters: [apiVersion, reason],
    urlParameters: [endpoint, hub, connectionId],
    headerParameters: [accept],
    serializer
};
const connectionExistsOperationSpec = {
    path: "/api/hubs/{hub}/connections/{connectionId}",
    httpMethod: "HEAD",
    responses: {
        200: {},
        404: {},
        default: {
            headersMapper: WebPubSubConnectionExistsExceptionHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, hub, connectionId],
    serializer
};
const sendToConnection$binaryOperationSpec = {
    path: "/api/hubs/{hub}/connections/{connectionId}/:send",
    httpMethod: "POST",
    responses: {
        202: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubSendToConnectionExceptionHeaders
        }
    },
    requestBody: message,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, hub, connectionId],
    headerParameters: [contentType, accept2],
    mediaType: "binary",
    serializer
};
const sendToConnection$textOperationSpec = {
    path: "/api/hubs/{hub}/connections/{connectionId}/:send",
    httpMethod: "POST",
    responses: {
        202: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubSendToConnectionExceptionHeaders
        }
    },
    requestBody: message1,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, hub, connectionId],
    headerParameters: [contentType1, accept3],
    mediaType: "text",
    serializer
};
const removeConnectionFromAllGroupsOperationSpec = {
    path: "/api/hubs/{hub}/connections/{connectionId}/groups",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubRemoveConnectionFromAllGroupsExceptionHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, hub, connectionId],
    headerParameters: [accept],
    serializer
};
const groupExistsOperationSpec = {
    path: "/api/hubs/{hub}/groups/{group}",
    httpMethod: "HEAD",
    responses: {
        200: {},
        404: {},
        default: {
            headersMapper: WebPubSubGroupExistsExceptionHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, hub, group],
    serializer
};
const closeGroupConnectionsOperationSpec = {
    path: "/api/hubs/{hub}/groups/{group}/:closeConnections",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubCloseGroupConnectionsExceptionHeaders
        }
    },
    queryParameters: [
        apiVersion,
        excluded,
        reason
    ],
    urlParameters: [endpoint, hub, group],
    headerParameters: [accept],
    serializer
};
const sendToGroup$binaryOperationSpec = {
    path: "/api/hubs/{hub}/groups/{group}/:send",
    httpMethod: "POST",
    responses: {
        202: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubSendToGroupExceptionHeaders
        }
    },
    requestBody: message,
    queryParameters: [
        apiVersion,
        excludedConnections,
        filter
    ],
    urlParameters: [endpoint, hub, group],
    headerParameters: [contentType, accept2],
    mediaType: "binary",
    serializer
};
const sendToGroup$textOperationSpec = {
    path: "/api/hubs/{hub}/groups/{group}/:send",
    httpMethod: "POST",
    responses: {
        202: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubSendToGroupExceptionHeaders
        }
    },
    requestBody: message1,
    queryParameters: [
        apiVersion,
        excludedConnections,
        filter
    ],
    urlParameters: [endpoint, hub, group],
    headerParameters: [contentType1, accept3],
    mediaType: "text",
    serializer
};
const removeConnectionFromGroupOperationSpec = {
    path: "/api/hubs/{hub}/groups/{group}/connections/{connectionId}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubRemoveConnectionFromGroupExceptionHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        endpoint,
        hub,
        connectionId,
        group
    ],
    headerParameters: [accept],
    serializer
};
const addConnectionToGroupOperationSpec = {
    path: "/api/hubs/{hub}/groups/{group}/connections/{connectionId}",
    httpMethod: "PUT",
    responses: {
        200: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubAddConnectionToGroupExceptionHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        endpoint,
        hub,
        connectionId,
        group
    ],
    headerParameters: [accept],
    serializer
};
const revokePermissionOperationSpec = {
    path: "/api/hubs/{hub}/permissions/{permission}/connections/{connectionId}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubRevokePermissionExceptionHeaders
        }
    },
    queryParameters: [apiVersion, targetName],
    urlParameters: [
        endpoint,
        hub,
        connectionId,
        permission
    ],
    headerParameters: [accept],
    serializer
};
const checkPermissionOperationSpec = {
    path: "/api/hubs/{hub}/permissions/{permission}/connections/{connectionId}",
    httpMethod: "HEAD",
    responses: {
        200: {},
        404: {},
        default: {
            headersMapper: WebPubSubCheckPermissionExceptionHeaders
        }
    },
    queryParameters: [apiVersion, targetName],
    urlParameters: [
        endpoint,
        hub,
        connectionId,
        permission
    ],
    serializer
};
const grantPermissionOperationSpec = {
    path: "/api/hubs/{hub}/permissions/{permission}/connections/{connectionId}",
    httpMethod: "PUT",
    responses: {
        200: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubGrantPermissionExceptionHeaders
        }
    },
    queryParameters: [apiVersion, targetName],
    urlParameters: [
        endpoint,
        hub,
        connectionId,
        permission
    ],
    headerParameters: [accept],
    serializer
};
const userExistsOperationSpec = {
    path: "/api/hubs/{hub}/users/{userId}",
    httpMethod: "HEAD",
    responses: {
        200: {},
        404: {},
        default: {
            headersMapper: WebPubSubUserExistsExceptionHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, hub, userId1],
    serializer
};
const closeUserConnectionsOperationSpec = {
    path: "/api/hubs/{hub}/users/{userId}/:closeConnections",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubCloseUserConnectionsExceptionHeaders
        }
    },
    queryParameters: [
        apiVersion,
        excluded,
        reason
    ],
    urlParameters: [endpoint, hub, userId1],
    headerParameters: [accept],
    serializer
};
const sendToUser$binaryOperationSpec = {
    path: "/api/hubs/{hub}/users/{userId}/:send",
    httpMethod: "POST",
    responses: {
        202: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubSendToUserExceptionHeaders
        }
    },
    requestBody: message,
    queryParameters: [apiVersion, filter],
    urlParameters: [endpoint, hub, userId1],
    headerParameters: [contentType, accept2],
    mediaType: "binary",
    serializer
};
const sendToUser$textOperationSpec = {
    path: "/api/hubs/{hub}/users/{userId}/:send",
    httpMethod: "POST",
    responses: {
        202: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubSendToUserExceptionHeaders
        }
    },
    requestBody: message1,
    queryParameters: [apiVersion, filter],
    urlParameters: [endpoint, hub, userId1],
    headerParameters: [contentType1, accept3],
    mediaType: "text",
    serializer
};
const removeUserFromAllGroupsOperationSpec = {
    path: "/api/hubs/{hub}/users/{userId}/groups",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubRemoveUserFromAllGroupsExceptionHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, hub, userId1],
    headerParameters: [accept],
    serializer
};
const removeUserFromGroupOperationSpec = {
    path: "/api/hubs/{hub}/users/{userId}/groups/{group}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubRemoveUserFromGroupExceptionHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        endpoint,
        hub,
        group,
        userId1
    ],
    headerParameters: [accept],
    serializer
};
const addUserToGroupOperationSpec = {
    path: "/api/hubs/{hub}/users/{userId}/groups/{group}",
    httpMethod: "PUT",
    responses: {
        200: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubAddUserToGroupExceptionHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        endpoint,
        hub,
        group,
        userId1
    ],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** @internal */
class GeneratedClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the GeneratedClient class.
     * @param endpoint HTTP or HTTPS endpoint for the Web PubSub service instance.
     * @param options The parameter options
     */
    constructor(endpoint, options) {
        var _a, _b;
        if (endpoint === undefined) {
            throw new Error("'endpoint' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8"
        };
        const packageDetails = `azsdk-js-web-pubsub/1.1.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, baseUri: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "{Endpoint}" });
        super(optionsWithDefaults);
        // Parameter assignments
        this.endpoint = endpoint;
        // Assigning values to Constant parameters
        this.apiVersion = options.apiVersion || "2022-11-01";
        this.healthApi = new HealthApiImpl(this);
        this.webPubSub = new WebPubSubImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            async sendRequest(request, next) {
                const param = request.url.split("?");
                if (param.length > 1) {
                    const newParams = param[1].split("&").map((item) => {
                        if (item.indexOf("api-version") > -1) {
                            return "api-version=" + apiVersion;
                        }
                        else {
                            return item;
                        }
                    });
                    request.url = param[0] + "?" + newParams.join("&");
                }
                return next(request);
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
}

// Copyright (c) Microsoft Corporation.
/** @internal */
const tracingClient = coreTracing.createTracingClient({
    namespace: "Microsoft.WebPubSub",
    packageName: "@azure/web-pubsub",
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function isRequestBody(obj) {
    return (typeof obj === "function" ||
        (typeof obj === "object" &&
            obj != null &&
            (obj.constructor.name === "ArrayBuffer" ||
                obj.constructor.name === "Blob" ||
                ArrayBuffer.isView(obj))));
}
function getPayloadForMessage(message, options) {
    if ((options === null || options === void 0 ? void 0 : options.contentType) === "text/plain") {
        if (typeof message !== "string") {
            throw new TypeError("Message must be a string.");
        }
        return { contentType: "text/plain", payload: message };
    }
    else if (isRequestBody(message)) {
        return { contentType: "application/octet-stream", payload: message };
    }
    else {
        return { contentType: "application/json", payload: JSON.stringify(message) };
    }
}
function formatNullAndUndefined(input) {
    if (input === null || input === undefined) {
        return "null";
    }
    return input;
}
function escapeQuotesIfString(input, previous) {
    let result = input;
    if (typeof input === "string") {
        result = input.replace(/'/g, "''");
        // check if we need to escape this literal
        if (!previous.trim().endsWith("'")) {
            result = `'${result}'`;
        }
    }
    return result;
}
/**
 * Escapes an odata filter expression to avoid errors with quoting string literals.
 * Example usage:
 * ```ts
 * const userId = "vic's";
 * const anonymous = null;
 * const length = 3
 * const filter = odata`userId eq ${anonymous} or userId eq ${userId} or length(userId) > ${length}`;
 * ```
 * @param strings - Array of strings for the expression
 * @param values - Array of values for the expression
 */
function odata(strings, ...values) {
    const results = [];
    for (let i = 0; i < strings.length; i++) {
        results.push(strings[i]);
        if (i < values.length) {
            if (values[i] === null || values[i] === undefined) {
                results.push(formatNullAndUndefined(values[i]));
            }
            else {
                results.push(escapeQuotesIfString(values[i], strings[i]));
            }
        }
    }
    return results.join("");
}

// Copyright (c) Microsoft Corporation.
/**
 * @hidden
 */
class WebPubSubGroupImpl {
    /**
     * @internal
     */
    constructor(client, hubName, groupName) {
        /**
         * The Web PubSub API version being used by this client
         */
        this.apiVersion = "2020-10-01";
        this.client = client;
        this.groupName = groupName;
        this.hubName = hubName;
    }
    /**
     * Add a specific connection to this group
     *
     * @param connectionId - The connection id to add to this group
     * @param options - Additional options
     */
    async addConnection(connectionId, options = {}) {
        let response;
        function onResponse(rawResponse, flatResponse) {
            response = rawResponse;
            if (options.onResponse) {
                options.onResponse(rawResponse, flatResponse);
            }
        }
        return tracingClient.withSpan("WebPubSubGroupClient.addConnection", options, async (updatedOptions) => {
            await this.client.webPubSub.addConnectionToGroup(this.hubName, this.groupName, connectionId, Object.assign(Object.assign({}, updatedOptions), { onResponse }));
            if (response.status === 404) {
                throw new coreRestPipeline.RestError(`Connection id '${connectionId}' doesn't exist`, {
                    statusCode: response === null || response === void 0 ? void 0 : response.status,
                    request: response === null || response === void 0 ? void 0 : response.request,
                    response: response,
                });
            }
        });
    }
    /**
     * Remove a specific connection from this group
     *
     * @param connectionId - The connection id to remove from this group
     * @param options - Additional options
     */
    async removeConnection(connectionId, options = {}) {
        return tracingClient.withSpan("WebPubSubGroupClient.removeConnection", options, (updatedOptions) => {
            return this.client.webPubSub.removeConnectionFromGroup(this.hubName, this.groupName, connectionId, updatedOptions);
        });
    }
    /**
     * Close all connections to this group
     *
     * @param options - Additional options
     */
    async closeAllConnections(options = {}) {
        return tracingClient.withSpan("WebPubSubGroupClient.closeAllConnections", options, (updatedOptions) => {
            return this.client.webPubSub.closeGroupConnections(this.hubName, this.groupName, updatedOptions);
        });
    }
    /**
     * Add a user to this group
     *
     * @param username - The user name to add
     * @param options - Additional options
     */
    async addUser(username, options = {}) {
        return tracingClient.withSpan("WebPubSubGroupClient.addUser", options, (updatedOptions) => {
            return this.client.webPubSub.addUserToGroup(this.hubName, this.groupName, username, updatedOptions);
        });
    }
    /**
     * Remove a user from this group
     *
     * @param username - The user name to remove
     * @param options - Additional options
     */
    async removeUser(username, options = {}) {
        return tracingClient.withSpan("WebPubSubGroupClient.removeUser", options, (updatedOptions) => {
            return this.client.webPubSub.removeUserFromGroup(this.hubName, this.groupName, username, updatedOptions);
        });
    }
    async sendToAll(message, options = {}) {
        return tracingClient.withSpan("WebPubSubGroupClient.sendToAll", options, (updatedOptions) => {
            const { contentType, payload } = getPayloadForMessage(message, updatedOptions);
            return this.client.webPubSub.sendToGroup(this.hubName, this.groupName, contentType, payload, updatedOptions);
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * The programmatic identifier of the webPubSubKeyCredentialPolicy.
 */
const webPubSubKeyCredentialPolicyName = "webPubSubKeyCredentialPolicy";
/**
 * Create an HTTP pipeline policy to authenticate a request
 * using an `AzureKeyCredential` for Text Analytics
 * @internal
 */
function webPubSubKeyCredentialPolicy(credential) {
    return {
        name: webPubSubKeyCredentialPolicyName,
        sendRequest(request, next) {
            const bearerToken = jwt__default["default"].sign({}, credential.key, {
                audience: request.url,
                expiresIn: "1h",
                algorithm: "HS256",
            });
            request.headers.set("Authorization", `Bearer ${bearerToken}`);
            return next(request);
        },
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * The `@azure/logger` configuration for this package.
 */
const logger = logger$1.createClientLogger("web-pubsub");

// Copyright (c) Microsoft Corporation.
function parseConnectionString(conn) {
    const parsed = {};
    conn.split(";").forEach((i) => {
        const assignmentPos = i.indexOf("=");
        if (assignmentPos === -1)
            return;
        const key = i.substring(0, assignmentPos).toLowerCase();
        const value = i.substring(assignmentPos + 1);
        parsed[key] = value;
    });
    let endpointPart = parsed["endpoint"];
    if (!endpointPart)
        throw new TypeError("connection string missing endpoint");
    if (!endpointPart.startsWith("http")) {
        endpointPart = `https://${endpointPart}`;
    }
    const key = parsed["accesskey"];
    if (!key)
        throw new TypeError("connection string missing access key");
    const credential = new coreAuth.AzureKeyCredential(key);
    const port = parsed["port"];
    const url = new URL(endpointPart);
    url.port = port;
    const endpoint = url.toString();
    url.port = "";
    return { credential, endpoint };
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const webPubSubReverseProxyPolicyName = "webPubSubReverseProxyPolicy";
/**
 * Create an HTTP pipeline policy to use a reverse proxy.
 * This is generally going to be an Azure APIM endpoint.
 * @internal
 */
function webPubSubReverseProxyPolicy(endpoint) {
    const rpEndpointUrl = new URL(endpoint);
    return {
        name: webPubSubReverseProxyPolicyName,
        sendRequest(request, next) {
            const parsedUrl = new URL(request.url);
            parsedUrl.host = rpEndpointUrl.host;
            request.url = parsedUrl.toString();
            return next(request);
        },
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * Client for connecting to a Web PubSub hub
 */
class WebPubSubServiceClient {
    constructor(endpointOrConnectionString, credsOrHubName, hubNameOrOpts, opts) {
        var _a, _b, _c, _d, _e, _f;
        /**
         * The Web PubSub API version being used by this client
         */
        this.apiVersion = "2022-11-01";
        // unpack constructor arguments
        if (typeof credsOrHubName === "object") {
            this.endpoint = endpointOrConnectionString;
            this.hubName = hubNameOrOpts;
            this.clientOptions = opts;
            this.credential = credsOrHubName;
        }
        else {
            const parsedCs = parseConnectionString(endpointOrConnectionString);
            this.endpoint = parsedCs.endpoint;
            this.credential = parsedCs.credential;
            this.hubName = credsOrHubName;
            this.clientOptions = hubNameOrOpts;
        }
        const internalPipelineOptions = Object.assign(Object.assign(Object.assign({}, this.clientOptions), {
            apiVersion: this.apiVersion,
            loggingOptions: {
                additionalAllowedHeaderNames: (_b = (_a = this.clientOptions) === null || _a === void 0 ? void 0 : _a.loggingOptions) === null || _b === void 0 ? void 0 : _b.additionalAllowedHeaderNames,
                additionalAllowedQueryParameters: (_d = (_c = this.clientOptions) === null || _c === void 0 ? void 0 : _c.loggingOptions) === null || _d === void 0 ? void 0 : _d.additionalAllowedQueryParameters,
                logger: logger.info,
            },
        }), (coreAuth.isTokenCredential(this.credential)
            ? {
                credential: this.credential,
                credentialScopes: ["https://webpubsub.azure.com/.default"],
            }
            : {}));
        this.client = new GeneratedClient(this.endpoint, internalPipelineOptions);
        if (!coreAuth.isTokenCredential(this.credential)) {
            this.client.pipeline.addPolicy(webPubSubKeyCredentialPolicy(this.credential));
        }
        if ((_e = this.clientOptions) === null || _e === void 0 ? void 0 : _e.reverseProxyEndpoint) {
            this.client.pipeline.addPolicy(webPubSubReverseProxyPolicy((_f = this.clientOptions) === null || _f === void 0 ? void 0 : _f.reverseProxyEndpoint));
        }
    }
    /**
     * Get a client for a group
     * @param groupName - The name of the group to connect to.
     */
    group(groupName) {
        return new WebPubSubGroupImpl(this.client, this.hubName, groupName);
    }
    async sendToAll(message, options = {}) {
        return tracingClient.withSpan("WebPubSubServiceClient.sendToAll", options, (updatedOptions) => {
            const { contentType, payload } = getPayloadForMessage(message, updatedOptions);
            return this.client.webPubSub.sendToAll(this.hubName, contentType, payload, updatedOptions);
        });
    }
    async sendToUser(username, message, options = {}) {
        return tracingClient.withSpan("WebPubSubServiceClient.sendToUser", options, (updatedOptions) => {
            const { contentType, payload } = getPayloadForMessage(message, updatedOptions);
            return this.client.webPubSub.sendToUser(this.hubName, username, contentType, payload, updatedOptions);
        });
    }
    async sendToConnection(connectionId, message, options = {}) {
        return tracingClient.withSpan("WebPubSubServiceClient.sendToConnection", options, (updatedOptions) => {
            const { contentType, payload } = getPayloadForMessage(message, updatedOptions);
            return this.client.webPubSub.sendToConnection(this.hubName, connectionId, contentType, payload, updatedOptions);
        });
    }
    /**
     * Check if a specific connection is connected to this hub
     *
     * @param connectionId - Connection id to check
     * @param options - Additional options
     */
    async connectionExists(connectionId, options = {}) {
        let response;
        function onResponse(rawResponse, flatResponse) {
            response = rawResponse;
            if (options.onResponse) {
                options.onResponse(rawResponse, flatResponse);
            }
        }
        return tracingClient.withSpan("WebPubSubServiceClient.connectionExists", options, async (updatedOptions) => {
            await this.client.webPubSub.connectionExists(this.hubName, connectionId, Object.assign(Object.assign({}, updatedOptions), { onResponse }));
            if (response.status === 200) {
                return true;
            }
            else if (response.status === 404) {
                return false;
            }
            else {
                // this is sad - wish this was handled by autorest.
                throw new coreRestPipeline.RestError(response.bodyAsText, {
                    statusCode: response === null || response === void 0 ? void 0 : response.status,
                    request: response === null || response === void 0 ? void 0 : response.request,
                    response: response,
                });
            }
        });
    }
    /**
     * Close a specific connection to this hub
     *
     * @param connectionId - Connection id to close
     * @param options - Additional options
     */
    async closeConnection(connectionId, options = {}) {
        return tracingClient.withSpan("WebPubSubServiceClient.closeConnection", options, (updatedOptions) => {
            return this.client.webPubSub.closeConnection(this.hubName, connectionId, updatedOptions);
        });
    }
    /**
     * Close all connections to this hub
     *
     * @param options - Additional options
     */
    async closeAllConnections(options = {}) {
        return tracingClient.withSpan("WebPubSubServiceClient.closeAllConnections", options, (updatedOptions) => {
            return this.client.webPubSub.closeAllConnections(this.hubName, updatedOptions);
        });
    }
    /**
     * Close all connections with the given user id
     *
     * @param user - User id to close
     * @param options - Additional options
     */
    async closeUserConnections(userId, options = {}) {
        return tracingClient.withSpan("WebPubSubServiceClient.closeUserConnections", options, (updatedOptions) => {
            return this.client.webPubSub.closeUserConnections(this.hubName, userId, updatedOptions);
        });
    }
    /**
     * Remove a specific user from all groups they are joined to
     * @param userId - The user id to remove from all groups
     * @param options - Additional options
     */
    async removeUserFromAllGroups(userId, options = {}) {
        return tracingClient.withSpan("WebPubSubServiceClient.removeUserFromAllGroups", options, (updatedOptions) => {
            return this.client.webPubSub.removeUserFromAllGroups(this.hubName, userId, updatedOptions);
        });
    }
    /**
     * Remove a specific connection from all groups they are joined to
     * @param connectionId - The connection id to remove from all groups
     * @param options - Additional options
     */
    async removeConnectionFromAllGroups(connectionId, options = {}) {
        return tracingClient.withSpan("WebPubSubServiceClient.removeConnectionFromAllGroups", options, (updatedOptions) => {
            return this.client.webPubSub.removeConnectionFromAllGroups(this.hubName, connectionId, updatedOptions);
        });
    }
    /**
     * Check if a particular group exists (i.e. has active connections).
     *
     * @param groupName - The group name to check for
     * @param options - Additional options
     */
    async groupExists(groupName, options = {}) {
        let response;
        function onResponse(rawResponse, flatResponse) {
            response = rawResponse;
            if (options.onResponse) {
                options.onResponse(rawResponse, flatResponse);
            }
        }
        return tracingClient.withSpan("WebPubSubServiceClient.groupExists", options, async (updatedOptions) => {
            await this.client.webPubSub.groupExists(this.hubName, groupName, Object.assign(Object.assign({}, updatedOptions), { onResponse }));
            if (response.status === 200) {
                return true;
            }
            else if (response.status === 404) {
                return false;
            }
            else {
                throw new coreRestPipeline.RestError(response.bodyAsText, {
                    statusCode: response === null || response === void 0 ? void 0 : response.status,
                    request: response === null || response === void 0 ? void 0 : response.request,
                    response: response,
                });
            }
        });
    }
    /**
     * Check if a particular user is connected to this hub.
     *
     * @param username - The user name to check for
     * @param options - Additional options
     */
    async userExists(username, options = {}) {
        let response;
        function onResponse(rawResponse, flatResponse) {
            response = rawResponse;
            if (options.onResponse) {
                options.onResponse(rawResponse, flatResponse);
            }
        }
        return tracingClient.withSpan("WebPubSubServiceClient.userExists", options, async (updatedOptions) => {
            await this.client.webPubSub.userExists(this.hubName, username, Object.assign(Object.assign({}, updatedOptions), { onResponse }));
            if (response.status === 200) {
                return true;
            }
            else if (response.status === 404) {
                return false;
            }
            else {
                // this is sad - wish this was handled by autorest.
                throw new coreRestPipeline.RestError(response.bodyAsText, {
                    statusCode: response === null || response === void 0 ? void 0 : response.status,
                    request: response === null || response === void 0 ? void 0 : response.request,
                    response: response,
                });
            }
        });
    }
    /**
     * Grant permissions to a connection
     *
     * @param connectionId - The connection id to grant permissions to
     * @param Permission - The permission to grant
     * @param options - Additional options
     */
    async grantPermission(connectionId, permission, options = {}) {
        return tracingClient.withSpan("WebPubSubServiceClient.grantPermission", options, (updatedOptions) => {
            return this.client.webPubSub.grantPermission(this.hubName, permission, connectionId, updatedOptions);
        });
    }
    /**
     * Revoke permissions from a connection
     *
     * @param connectionId - The connection id to revoke permissions from
     * @param Permission - The permission to revoke
     * @param options - Additional options
     */
    async revokePermission(connectionId, permission, options = {}) {
        return tracingClient.withSpan("WebPubSubServiceClient.revokePermission", options, (updatedOptions) => {
            return this.client.webPubSub.revokePermission(this.hubName, permission, connectionId, updatedOptions);
        });
    }
    /**
     * Check if the connection has the specified permission
     *
     * @param connectionId - The connection id to check permission
     * @param Permission - The permission to check
     * @param options - Additional options
     */
    async hasPermission(connectionId, permission, options = {}) {
        let response;
        function onResponse(rawResponse, flatResponse) {
            response = rawResponse;
            if (options.onResponse) {
                options.onResponse(rawResponse, flatResponse);
            }
        }
        return tracingClient.withSpan("WebPubSubServiceClient.hasPermission", options, async (updatedOptions) => {
            await this.client.webPubSub.checkPermission(this.hubName, permission, connectionId, Object.assign(Object.assign({}, updatedOptions), { onResponse }));
            if (response.status === 200) {
                return true;
            }
            else if (response.status === 404) {
                return false;
            }
            else {
                // this is sad - wish this was handled by autorest.
                throw new coreRestPipeline.RestError(response.bodyAsText, {
                    statusCode: response === null || response === void 0 ? void 0 : response.status,
                    request: response === null || response === void 0 ? void 0 : response.request,
                    response: response,
                });
            }
        });
    }
    /**
     * Generate a token for a client to connect to the Azure Web PubSub service.
     *
     * @param options - Additional options
     */
    async getClientAccessToken(options = {}) {
        return tracingClient.withSpan("WebPubSubServiceClient.getClientAccessToken", options, async (updatedOptions) => {
            const endpoint = this.endpoint.endsWith("/") ? this.endpoint : this.endpoint + "/";
            const clientEndpoint = endpoint.replace(/(http)(s?:\/\/)/gi, "ws$2");
            const baseUrl = `${clientEndpoint}client/hubs/${this.hubName}`;
            let token;
            if (coreAuth.isTokenCredential(this.credential)) {
                const response = await this.client.webPubSub.generateClientToken(this.hubName, updatedOptions);
                token = response.token;
            }
            else {
                const key = this.credential.key;
                const audience = `${endpoint}client/hubs/${this.hubName}`;
                const payload = { role: options === null || options === void 0 ? void 0 : options.roles, "webpubsub.group": options === null || options === void 0 ? void 0 : options.groups };
                const signOptions = {
                    audience: audience,
                    expiresIn: (options === null || options === void 0 ? void 0 : options.expirationTimeInMinutes) === undefined
                        ? "1h"
                        : `${options.expirationTimeInMinutes}m`,
                    algorithm: "HS256",
                };
                if (options === null || options === void 0 ? void 0 : options.userId) {
                    signOptions.subject = options === null || options === void 0 ? void 0 : options.userId;
                }
                token = jwt__default["default"].sign(payload, key, signOptions);
            }
            return {
                token,
                baseUrl,
                url: `${baseUrl}?access_token=${token}`,
            };
        });
    }
}

Object.defineProperty(exports, 'AzureKeyCredential', {
    enumerable: true,
    get: function () { return coreAuth.AzureKeyCredential; }
});
exports.WebPubSubServiceClient = WebPubSubServiceClient;
exports.odata = odata;
//# sourceMappingURL=index.js.map
