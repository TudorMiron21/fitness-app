{"version":3,"file":"cloudEventsProtocols.js","sourceRoot":"","sources":["../../src/cloudEventsProtocols.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * Response of the connect event.\n */\nexport interface ConnectResponse {\n  /**\n   * Set the groups the connection would like to join.\n   */\n  groups?: string[];\n  /**\n   * Set the roles the connection belongs to.\n   */\n  roles?: string[];\n  /**\n   * Set the userId for the connection.\n   */\n  userId?: string;\n  /**\n   * Set the subprotocol for the connection to complete WebSocket handshake.\n   */\n  subprotocol?: string;\n}\n\n/**\n * The connection context representing the client WebSocket connection.\n */\nexport interface ConnectionContext {\n  /**\n   * The hub the connection belongs to.\n   */\n  hub: string;\n  /**\n   * The Id of the connection.\n   */\n  connectionId: string;\n  /**\n   * The event name of this CloudEvents request.\n   */\n  eventName: string;\n  /**\n   * The origin this CloudEvents request comes from.\n   */\n  origin: string;\n  /**\n   * The user id of the connection.\n   */\n  userId?: string;\n  /**\n   * The subprotocol of this connection.\n   */\n  subprotocol?: string;\n  /**\n   * Get the additional states for the connection, such states are perserved throughout the lifetime of the connection.\n   */\n  states: Record<string, any>;\n}\n\n/**\n * Request for the connect event.\n */\nexport interface ConnectRequest {\n  /**\n   * The context of current CloudEvents request.\n   */\n  context: ConnectionContext;\n  /**\n   * The claims that the client WebSocket connection has when it connects.\n   */\n  claims?: Record<string, string[]>;\n  /**\n   * The query that the client WebSocket connection has when it connects.\n   * @deprecated Please use queries instead.\n   */\n  query?: Record<string, string[]>;\n  /**\n   * The queries that the client WebSocket connection has when it connects.\n   */\n  queries?: Record<string, string[]>;\n  /**\n   * The headers that the client WebSocket connection has when it connects.\n   */\n  headers?: Record<string, string[]>;\n  /**\n   * The subprotocols that the client WebSocket connection uses to do handshake.\n   */\n  subprotocols?: string[];\n  /**\n   * The client certificate info that the client WebSocket connection uses to connect.\n   */\n  clientCertificates?: Certificate[];\n}\n\n/**\n * The client certificate.\n */\nexport interface Certificate {\n  /**\n   * The thumbprint of the certificate.\n   */\n  thumbprint: string;\n}\n\n/**\n * Request for the connected event.\n */\nexport interface ConnectedRequest {\n  /**\n   * The context of current CloudEvents request.\n   */\n  context: ConnectionContext;\n}\n\n/**\n * Request for the user event.\n */\nexport type UserEventRequest =\n  | {\n      /**\n       * The context of current CloudEvents request.\n       */\n      context: ConnectionContext;\n\n      /**\n       * The content data.\n       */\n      data: string;\n      /**\n       * The type of the data.\n       */\n      dataType: \"text\";\n    }\n  | {\n      /**\n       * The context of current CloudEvents request.\n       */\n      context: ConnectionContext;\n\n      /**\n       * The content data, when data type is `json`, the data is the result of JSON.parse, so the type of the data depends on user scenarios\n       */\n      data: unknown;\n\n      /**\n       * The type of the data.\n       */\n      dataType: \"json\";\n    }\n  | {\n      /**\n       * The context of current CloudEvents request.\n       */\n      context: ConnectionContext;\n\n      /**\n       * The content data.\n       */\n      data: ArrayBuffer;\n      /**\n       * The type of the data.\n       */\n      dataType: \"binary\";\n    };\n\n/**\n * Request for the disconnected event.\n */\nexport interface DisconnectedRequest {\n  /**\n   * The context of current CloudEvents request.\n   */\n  context: ConnectionContext;\n  /**\n   * The reason that the connection disconnects.\n   */\n  reason?: string;\n}\n\n/**\n * The handler to set connect event response\n */\nexport interface ConnectResponseHandler {\n  /**\n   * Set the state of the connection\n   * @param name - The name of the state\n   * @param value - The value of the state\n   */\n  setState(name: string, value: unknown): void;\n  /**\n   * Return success response to the service.\n   * @param response - The response for the connect event.\n   */\n  success(response?: ConnectResponse): void;\n  /**\n   * Return failed response and the service will reject the client WebSocket connection.\n   * @param code - Code can be 400 user error, 401 unauthorized and 500 server error.\n   * @param detail - The detail of the error.\n   */\n  fail(code: 400 | 401 | 500, detail?: string): void;\n}\n\n/**\n * The handler to set user event response\n */\nexport interface UserEventResponseHandler {\n  /**\n   * Set the state of the connection\n   * @param name - The name of the state\n   * @param value - The value of the state\n   */\n  setState(name: string, value: unknown): void;\n  /**\n   * Return success response with data to be delivered to the client WebSocket connection.\n   * @param data - The payload data to be returned to the client. Stringify the message if it is a JSON object.\n   * @param dataType - The type of the payload data.\n   */\n  success(data?: string | ArrayBuffer, dataType?: \"binary\" | \"text\" | \"json\"): void;\n  /**\n   * Return failed response and the service will close the client WebSocket connection.\n   * @param code - Code can be 400 user error, 401 unauthorized and 500 server error.\n   * @param detail - The detail of the error.\n   */\n  fail(code: 400 | 401 | 500, detail?: string): void;\n}\n\n/**\n * The options for the CloudEvents handler.\n */\nexport interface WebPubSubEventHandlerOptions {\n  /**\n   * Custom serving path for the path of the CloudEvents handler.\n   */\n  path?: string;\n\n  /**\n   * Handle 'connect' event, the service waits for the response to proceed.\n   */\n  handleConnect?: (connectRequest: ConnectRequest, connectResponse: ConnectResponseHandler) => void;\n\n  /**\n   * Handle user events, the service waits for the response to proceed.\n   */\n  handleUserEvent?: (\n    userEventRequest: UserEventRequest,\n    userEventResponse: UserEventResponseHandler\n  ) => void;\n\n  /**\n   * Event trigger for \"connected\" unblocking event. This is an unblocking event and the service does not wait for the response.\n   */\n  onConnected?: (connectedRequest: ConnectedRequest) => void;\n\n  /**\n   *\n   * Event triggers for \"disconnected\" unblocking event. This is an unblocking event and the service does not wait for the response.\n   */\n  onDisconnected?: (disconnectedRequest: DisconnectedRequest) => void;\n\n  /**\n   * If not specified, by default allow all the endpoints, otherwise only allow specified endpoints\n   */\n  allowedEndpoints?: string[];\n}\n"]}