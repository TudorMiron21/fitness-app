'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var url = require('url');
var logger$1 = require('@azure/logger');

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function isJsonObject(obj) {
    return obj && typeof obj === "object" && !Array.isArray(obj);
}
function toBase64JsonString(obj) {
    return Buffer.from(JSON.stringify(obj)).toString("base64");
}
function fromBase64JsonString(base64String) {
    if (base64String === undefined) {
        return {};
    }
    try {
        const buf = Buffer.from(base64String, "base64").toString();
        const parsed = JSON.parse(buf);
        return isJsonObject(parsed) ? parsed : {};
    }
    catch (e) {
        console.warn("Unexpected state format:" + e);
        return {};
    }
}
function getHttpHeader(req, key) {
    if (!key)
        return undefined;
    // According to https://nodejs.org/api/http.html#http_class_http_incomingmessage, header names are always lower-cased
    const value = req.headers[key.toLowerCase()];
    if (value === undefined) {
        return undefined;
    }
    if (typeof value === "string") {
        return value;
    }
    return value[0];
}
function readRequestBody(req) {
    return new Promise(function (resolve, reject) {
        const chunks = [];
        req.on("data", function (chunk) {
            chunks.push(chunk);
        });
        req.on("end", function () {
            const buffer = Buffer.concat(chunks);
            resolve(buffer);
        });
        // reject on request error
        req.on("error", function (err) {
            // This is not a "Second reject", just a different sort of failure
            reject(err);
        });
    });
}

// Copyright (c) Microsoft Corporation.
/**
 * The \@azure/logger configuration for this package.
 *
 * @internal
 */
const logger = logger$1.createClientLogger("web-pubsub-express");

// Copyright (c) Microsoft Corporation.
var EventType;
(function (EventType) {
    EventType[EventType["Connect"] = 0] = "Connect";
    EventType[EventType["Connected"] = 1] = "Connected";
    EventType[EventType["Disconnected"] = 2] = "Disconnected";
    EventType[EventType["UserEvent"] = 3] = "UserEvent";
})(EventType || (EventType = {}));
function getConnectResponseHandler(connectRequest, response) {
    const states = connectRequest.context.states;
    let modified = false;
    const handler = {
        setState(name, value) {
            states[name] = value;
            modified = true;
        },
        success(res) {
            response.statusCode = 200;
            if (modified) {
                response.setHeader("ce-connectionState", toBase64JsonString(states));
            }
            if (res === undefined) {
                response.end();
            }
            else {
                response.setHeader("Content-Type", "application/json; charset=utf-8");
                response.end(JSON.stringify(res));
            }
        },
        fail(code, detail) {
            response.statusCode = code;
            response.end(detail !== null && detail !== void 0 ? detail : "");
        },
    };
    return handler;
}
function getUserEventResponseHandler(userRequest, response) {
    const states = userRequest.context.states;
    let modified = false;
    const handler = {
        setState(name, value) {
            modified = true;
            states[name] = value;
        },
        success(data, dataType) {
            response.statusCode = 200;
            if (modified) {
                response.setHeader("ce-connectionState", toBase64JsonString(states));
            }
            switch (dataType) {
                case "json":
                    response.setHeader("Content-Type", "application/json; charset=utf-8");
                    break;
                case "text":
                    response.setHeader("Content-Type", "text/plain; charset=utf-8");
                    break;
                default:
                    response.setHeader("Content-Type", "application/octet-stream");
                    break;
            }
            response.end(data !== null && data !== void 0 ? data : "");
        },
        fail(code, detail) {
            response.statusCode = code;
            response.end(detail !== null && detail !== void 0 ? detail : "");
        },
    };
    return handler;
}
function getContext(request, origin) {
    const context = {
        signature: getHttpHeader(request, "ce-signature"),
        userId: getHttpHeader(request, "ce-userid"),
        hub: getHttpHeader(request, "ce-hub"),
        connectionId: getHttpHeader(request, "ce-connectionid"),
        eventName: getHttpHeader(request, "ce-eventname"),
        origin: origin,
        states: fromBase64JsonString(getHttpHeader(request, "ce-connectionstate")),
    };
    // TODO: validation
    return context;
}
function tryGetWebPubSubEvent(req) {
    // check ce-type to see if it is a valid WebPubSub CloudEvent request
    const prefix = "azure.webpubsub.";
    const connect = "azure.webpubsub.sys.connect";
    const connected = "azure.webpubsub.sys.connected";
    const disconnectd = "azure.webpubsub.sys.disconnected";
    const userPrefix = "azure.webpubsub.user.";
    const type = getHttpHeader(req, "ce-type");
    if (!(type === null || type === void 0 ? void 0 : type.startsWith(prefix))) {
        return undefined;
    }
    if (type.startsWith(userPrefix)) {
        return EventType.UserEvent;
    }
    switch (type) {
        case connect:
            return EventType.Connect;
        case connected:
            return EventType.Connected;
        case disconnectd:
            return EventType.Disconnected;
        default:
            return undefined;
    }
}
function isWebPubSubRequest(req) {
    return getHttpHeader(req, "ce-awpsversion") !== undefined;
}
async function readUserEventRequest(request, origin) {
    const contentTypeheader = getHttpHeader(request, "content-type");
    if (contentTypeheader === undefined) {
        return undefined;
    }
    const contentType = contentTypeheader.split(";")[0].trim();
    switch (contentType) {
        case "application/octet-stream":
            return {
                context: getContext(request, origin),
                data: await readRequestBody(request),
                dataType: "binary",
            };
        case "application/json":
            return {
                context: getContext(request, origin),
                data: JSON.parse((await readRequestBody(request)).toString()),
                dataType: "json",
            };
        case "text/plain":
            return {
                context: getContext(request, origin),
                data: (await readRequestBody(request)).toString(),
                dataType: "text",
            };
        default:
            return undefined;
    }
}
async function readSystemEventRequest(request, origin) {
    const body = (await readRequestBody(request)).toString();
    const parsedRequest = JSON.parse(body);
    parsedRequest.context = getContext(request, origin);
    return parsedRequest;
}
/**
 * @internal
 */
class CloudEventsDispatcher {
    constructor(hub, eventHandler) {
        this.hub = hub;
        this.eventHandler = eventHandler;
        this._allowAll = true;
        this._allowedOrigins = [];
        if (Array.isArray(eventHandler)) {
            throw new Error("Unexpected WebPubSubEventHandlerOptions");
        }
        if ((eventHandler === null || eventHandler === void 0 ? void 0 : eventHandler.allowedEndpoints) !== undefined) {
            this._allowedOrigins = eventHandler.allowedEndpoints.map((endpoint) => new url.URL(endpoint).host.toLowerCase());
            this._allowAll = false;
        }
    }
    handlePreflight(req, res) {
        if (!isWebPubSubRequest(req)) {
            return false;
        }
        const origin = getHttpHeader(req, "webhook-request-origin");
        if (origin === undefined) {
            logger.warning("Expecting webhook-request-origin header.");
            res.statusCode = 400;
        }
        else if (this._allowAll) {
            res.setHeader("WebHook-Allowed-Origin", "*");
        }
        else {
            // service to do the check
            res.setHeader("WebHook-Allowed-Origin", this._allowedOrigins);
        }
        res.end();
        return true;
    }
    async handleRequest(request, response) {
        var _a, _b, _c, _d;
        if (!isWebPubSubRequest(request)) {
            return false;
        }
        // check if it is a valid WebPubSub cloud events
        const origin = getHttpHeader(request, "webhook-request-origin");
        if (origin === undefined) {
            return false;
        }
        const eventType = tryGetWebPubSubEvent(request);
        if (eventType === undefined) {
            return false;
        }
        // check if hub matches
        const hub = getHttpHeader(request, "ce-hub");
        if ((hub === null || hub === void 0 ? void 0 : hub.toUpperCase()) !== this.hub.toUpperCase()) {
            return false;
        }
        // No need to read body if handler is not specified
        switch (eventType) {
            case EventType.Connect:
                if (!((_a = this.eventHandler) === null || _a === void 0 ? void 0 : _a.handleConnect)) {
                    response.end();
                    return true;
                }
                break;
            case EventType.Connected:
                if (!((_b = this.eventHandler) === null || _b === void 0 ? void 0 : _b.onConnected)) {
                    response.end();
                    return true;
                }
                break;
            case EventType.Disconnected:
                if (!((_c = this.eventHandler) === null || _c === void 0 ? void 0 : _c.onDisconnected)) {
                    response.end();
                    return true;
                }
                break;
            case EventType.UserEvent:
                if (!((_d = this.eventHandler) === null || _d === void 0 ? void 0 : _d.handleUserEvent)) {
                    response.end();
                    return true;
                }
                break;
            default:
                logger.warning(`Unknown EventType ${eventType}`);
                return false;
        }
        switch (eventType) {
            case EventType.Connect: {
                const connectRequest = await readSystemEventRequest(request, origin);
                // service passes out query property, assign it to queries
                connectRequest.queries = connectRequest.query;
                logger.verbose(connectRequest);
                this.eventHandler.handleConnect(connectRequest, getConnectResponseHandler(connectRequest, response));
                return true;
            }
            case EventType.Connected: {
                // for unblocking events, we responds to the service as early as possible
                response.end();
                const connectedRequest = await readSystemEventRequest(request, origin);
                logger.verbose(connectedRequest);
                this.eventHandler.onConnected(connectedRequest);
                return true;
            }
            case EventType.Disconnected: {
                // for unblocking events, we responds to the service as early as possible
                response.end();
                const disconnectedRequest = await readSystemEventRequest(request, origin);
                logger.verbose(disconnectedRequest);
                this.eventHandler.onDisconnected(disconnectedRequest);
                return true;
            }
            case EventType.UserEvent: {
                const userRequest = await readUserEventRequest(request, origin);
                if (userRequest === undefined) {
                    logger.warning(`Unsupported content type ${getHttpHeader(request, "content-type")}`);
                    return false;
                }
                logger.verbose(userRequest);
                this.eventHandler.handleUserEvent(userRequest, getUserEventResponseHandler(userRequest, response));
                return true;
            }
            default:
                logger.warning(`Unknown EventType ${eventType}`);
                return false;
        }
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * The handler to handle incoming CloudEvents messages
 */
class WebPubSubEventHandler {
    /**
     * Creates an instance of a WebPubSubEventHandler for handling incoming CloudEvents messages.
     *
     * Example usage:
     * ```ts
     * import express from "express";
     * import { WebPubSubEventHandler } from "@azure/web-pubsub-express";
     * const endpoint = "https://xxxx.webpubsubdev.azure.com"
     * const handler = new WebPubSubEventHandler('chat', {
     *   handleConnect: (req, res) => {
     *     console.log(JSON.stringify(req));
     *     return {};
     *   },
     *   onConnected: req => {
     *     console.log(JSON.stringify(req));
     *   },
     *   handleUserEvent: (req, res) => {
     *     console.log(JSON.stringify(req));
     *     res.success("Hey " + req.data, req.dataType);
     *    };
     *   allowedEndpoints: [ endpoint ]
     *  },
     * });
     * ```
     *
     * @param hub - The name of the hub to listen to
     * @param options - Options to configure the event handler
     */
    constructor(hub, options) {
        var _a;
        this.hub = hub;
        const path = ((_a = options === null || options === void 0 ? void 0 : options.path) !== null && _a !== void 0 ? _a : `/api/webpubsub/hubs/${hub}/`).toLowerCase();
        this.path = path.endsWith("/") ? path : path + "/";
        this._cloudEventsHandler = new CloudEventsDispatcher(this.hub, options);
    }
    /**
     * Get the middleware to process the CloudEvents requests
     */
    getMiddleware() {
        return async (req, res, next) => {
            // Request originalUrl can contain query while baseUrl + path not
            let requestUrl = (req.baseUrl + req.path).toLowerCase();
            // normalize the Url
            requestUrl = requestUrl.endsWith("/") ? requestUrl : requestUrl + "/";
            if (requestUrl.startsWith(this.path)) {
                if (req.method === "OPTIONS") {
                    if (this._cloudEventsHandler.handlePreflight(req, res)) {
                        return;
                    }
                }
                else if (req.method === "POST") {
                    try {
                        if (await this._cloudEventsHandler.handleRequest(req, res)) {
                            return;
                        }
                    }
                    catch (err) {
                        next(err);
                        return;
                    }
                }
            }
            next();
        };
    }
}

exports.WebPubSubEventHandler = WebPubSubEventHandler;
//# sourceMappingURL=index.js.map
